/**
 * Generated by orval v6.15.0 üç∫
 * Do not edit manually.
 * PortainerEE API
 * Portainer API is an HTTP API served by Portainer. It is used by the Portainer UI and everything you can do with the UI can be done using the HTTP API.
Examples are available at https://documentation.portainer.io/api/api-examples/
You can find out more about Portainer at [http://portainer.io](http://portainer.io) and get some support on [Slack](http://portainer.io/slack/).

# Authentication

Most of the API environments(endpoints) require to be authenticated as well as some level of authorization to be used.
Portainer API uses JSON Web Token to manage authentication and thus requires you to provide a token in the **Authorization** header of each request
with the **Bearer** authentication mechanism.

Example:

```
Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsInJvbGUiOjEsImV4cCI6MTQ5OTM3NjE1NH0.NJ6vE8FY1WG6jsRQzfMqeatJ4vh2TWAeeYfDhP71YEE
```

# Security

Each API environment(endpoint) has an associated access policy, it is documented in the description of each environment(endpoint).

Different access policies are available:

- Public access
- Authenticated access
- Restricted access
- Administrator access

### Public access

No authentication is required to access the environments(endpoints) with this access policy.

### Authenticated access

Authentication is required to access the environments(endpoints) with this access policy.

### Restricted access

Authentication is required to access the environments(endpoints) with this access policy.
Extra-checks might be added to ensure access to the resource is granted. Returned data might also be filtered.

### Administrator access

Authentication as well as an administrator role are required to access the environments(endpoints) with this access policy.

# Execute Docker requests

Portainer **DO NOT** expose specific environments(endpoints) to manage your Docker resources (create a container, remove a volume, etc...).

Instead, it acts as a reverse-proxy to the Docker HTTP API. This means that you can execute Docker requests **via** the Portainer HTTP API.

To do so, you can use the `/endpoints/{id}/docker` Portainer API environment(endpoint) (which is not documented below due to Swagger limitations). This environment(endpoint) has a restricted access policy so you still need to be authenticated to be able to query this environment(endpoint). Any query on this environment(endpoint) will be proxied to the Docker API of the associated environment(endpoint) (requests and responses objects are the same as documented in the Docker API).

# Private Registry

Using private registry, you will need to pass a based64 encoded JSON string ‚Äò{"registryId":\<registryID value\>}‚Äô inside the Request Header. The parameter name is "X-Registry-Auth".
\<registryID value\> - The registry ID where the repository was created.

Example:

```
eyJyZWdpc3RyeUlkIjoxfQ==
```

**NOTE**: You can find more information on how to query the Docker API in the [Docker official documentation](https://docs.docker.com/engine/api/v1.30/) as well as in [this Portainer example](https://documentation.portainer.io/api/api-examples/).

 * OpenAPI spec version: 2.19.0
 */
import axios from 'axios';
import type { AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { useQuery, useMutation } from 'react-query';
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from 'react-query';

import type {
  PortainerDockerSnapshotRaw,
  PortainerDockerContainerSnapshot,
  SnapshotContainersListParams,
  PortainereeEndpoint,
  EndpointListParams,
  EndpointCreateBody,
  EndpointsEndpointUpdatePayload,
  PostEndpointsIdDockerV2BrowsePutBody,
  PostEndpointsIdDockerV2BrowsePutParams,
  EndpointsDockerhubStatusResponse,
  EndpointedgeGenerateKeyResponse,
  EndpointedgeConfigResponse,
  EndpointedgeEndpointEdgeStatusInspectResponse,
  TypesServiceUpdateResponse,
  EndpointsForceUpdateServicePayload,
  EndpointsResourcePoolUpdatePayload,
  PortainereeRegistry,
  EndpointRegistriesListParams,
  EndpointsRegistryAccessPayload,
  EndpointsEndpointSettingsUpdatePayload,
  EndpointedgeEdgeAsyncResponse,
  EndpointsEndpointCreateGlobalKeyResponse,
} from '../portainerEEAPI.schemas';

/**
 * **Access policy**:
 * @summary Fetch latest snapshot of environment
 */
export const snapshotInspect = (
  environmentId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainerDockerSnapshotRaw>> =>
  axios.get(`/docker/${environmentId}/snapshot`, options);

export const getSnapshotInspectQueryKey = (environmentId: number) =>
  [`/docker/${environmentId}/snapshot`] as const;

export const getSnapshotInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof snapshotInspect>>,
  TError = AxiosError<void>
>(
  environmentId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof snapshotInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof snapshotInspect>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSnapshotInspectQueryKey(environmentId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof snapshotInspect>>> = ({
    signal,
  }) => snapshotInspect(environmentId, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!environmentId, ...queryOptions };
};

export type SnapshotInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof snapshotInspect>>
>;
export type SnapshotInspectQueryError = AxiosError<void>;

export const useSnapshotInspect = <
  TData = Awaited<ReturnType<typeof snapshotInspect>>,
  TError = AxiosError<void>
>(
  environmentId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof snapshotInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getSnapshotInspectQueryOptions(environmentId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * **Access policy**:
 * @summary Fetch container from a snapshot
 */
export const snapshotContainerInspect = (
  environmentId: number,
  containerId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainerDockerContainerSnapshot>> =>
  axios.get(
    `/docker/${environmentId}/snapshot/container/${containerId}`,
    options
  );

export const getSnapshotContainerInspectQueryKey = (
  environmentId: number,
  containerId: number
) => [`/docker/${environmentId}/snapshot/container/${containerId}`] as const;

export const getSnapshotContainerInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof snapshotContainerInspect>>,
  TError = AxiosError<void>
>(
  environmentId: number,
  containerId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof snapshotContainerInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof snapshotContainerInspect>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSnapshotContainerInspectQueryKey(environmentId, containerId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof snapshotContainerInspect>>
  > = ({ signal }) =>
    snapshotContainerInspect(environmentId, containerId, {
      signal,
      ...axiosOptions,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!(environmentId && containerId),
    ...queryOptions,
  };
};

export type SnapshotContainerInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof snapshotContainerInspect>>
>;
export type SnapshotContainerInspectQueryError = AxiosError<void>;

export const useSnapshotContainerInspect = <
  TData = Awaited<ReturnType<typeof snapshotContainerInspect>>,
  TError = AxiosError<void>
>(
  environmentId: number,
  containerId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof snapshotContainerInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getSnapshotContainerInspectQueryOptions(
    environmentId,
    containerId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * **Access policy**:
 * @summary Fetch containers list from a snapshot
 */
export const snapshotContainersList = (
  environmentId: number,
  params?: SnapshotContainersListParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainerDockerContainerSnapshot>> =>
  axios.get(`/docker/${environmentId}/snapshot/containers`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getSnapshotContainersListQueryKey = (
  environmentId: number,
  params?: SnapshotContainersListParams
) =>
  [
    `/docker/${environmentId}/snapshot/containers`,
    ...(params ? [params] : []),
  ] as const;

export const getSnapshotContainersListQueryOptions = <
  TData = Awaited<ReturnType<typeof snapshotContainersList>>,
  TError = AxiosError<void>
>(
  environmentId: number,
  params?: SnapshotContainersListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof snapshotContainersList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof snapshotContainersList>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getSnapshotContainersListQueryKey(environmentId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof snapshotContainersList>>
  > = ({ signal }) =>
    snapshotContainersList(environmentId, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!environmentId, ...queryOptions };
};

export type SnapshotContainersListQueryResult = NonNullable<
  Awaited<ReturnType<typeof snapshotContainersList>>
>;
export type SnapshotContainersListQueryError = AxiosError<void>;

export const useSnapshotContainersList = <
  TData = Awaited<ReturnType<typeof snapshotContainersList>>,
  TError = AxiosError<void>
>(
  environmentId: number,
  params?: SnapshotContainersListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof snapshotContainersList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getSnapshotContainersListQueryOptions(
    environmentId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * List all environments(endpoints) based on the current user authorizations. Will
return all environments(endpoints) if using an administrator or team leader account otherwise it will
only return authorized environments(endpoints).
**Access policy**: restricted
 * @summary List environments(endpoints)
 */
export const endpointList = (
  params?: EndpointListParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeEndpoint[]>> =>
  axios.get(`/endpoints`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getEndpointListQueryKey = (params?: EndpointListParams) =>
  [`/endpoints`, ...(params ? [params] : [])] as const;

export const getEndpointListQueryOptions = <
  TData = Awaited<ReturnType<typeof endpointList>>,
  TError = AxiosError<void>
>(
  params?: EndpointListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof endpointList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof endpointList>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEndpointListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof endpointList>>> = ({
    signal,
  }) => endpointList(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions };
};

export type EndpointListQueryResult = NonNullable<
  Awaited<ReturnType<typeof endpointList>>
>;
export type EndpointListQueryError = AxiosError<void>;

export const useEndpointList = <
  TData = Awaited<ReturnType<typeof endpointList>>,
  TError = AxiosError<void>
>(
  params?: EndpointListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof endpointList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getEndpointListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new environment(endpoint) that will be used to manage an environment(endpoint).
 **Access policy**: administrator
 * @summary Create a new environment(endpoint)
 */
export const endpointCreate = (
  endpointCreateBody: EndpointCreateBody,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeEndpoint>> => {
  const formData = new FormData();
  formData.append('Name', endpointCreateBody.Name);
  formData.append(
    'EndpointCreationType',
    endpointCreateBody.EndpointCreationType.toString()
  );
  if (endpointCreateBody.URL !== undefined) {
    formData.append('URL', endpointCreateBody.URL);
  }
  if (endpointCreateBody.PublicURL !== undefined) {
    formData.append('PublicURL', endpointCreateBody.PublicURL);
  }
  if (endpointCreateBody.GroupID !== undefined) {
    formData.append('GroupID', endpointCreateBody.GroupID.toString());
  }
  if (endpointCreateBody.TLS !== undefined) {
    formData.append('TLS', endpointCreateBody.TLS.toString());
  }
  if (endpointCreateBody.TLSSkipVerify !== undefined) {
    formData.append(
      'TLSSkipVerify',
      endpointCreateBody.TLSSkipVerify.toString()
    );
  }
  if (endpointCreateBody.TLSSkipClientVerify !== undefined) {
    formData.append(
      'TLSSkipClientVerify',
      endpointCreateBody.TLSSkipClientVerify.toString()
    );
  }
  if (endpointCreateBody.TLSCACertFile !== undefined) {
    formData.append('TLSCACertFile', endpointCreateBody.TLSCACertFile);
  }
  if (endpointCreateBody.TLSCertFile !== undefined) {
    formData.append('TLSCertFile', endpointCreateBody.TLSCertFile);
  }
  if (endpointCreateBody.TLSKeyFile !== undefined) {
    formData.append('TLSKeyFile', endpointCreateBody.TLSKeyFile);
  }
  if (endpointCreateBody.AzureApplicationID !== undefined) {
    formData.append(
      'AzureApplicationID',
      endpointCreateBody.AzureApplicationID
    );
  }
  if (endpointCreateBody.AzureTenantID !== undefined) {
    formData.append('AzureTenantID', endpointCreateBody.AzureTenantID);
  }
  if (endpointCreateBody.AzureAuthenticationKey !== undefined) {
    formData.append(
      'AzureAuthenticationKey',
      endpointCreateBody.AzureAuthenticationKey
    );
  }
  if (endpointCreateBody.TagIds !== undefined) {
    endpointCreateBody.TagIds.forEach((value) =>
      formData.append('TagIds', String(value))
    );
  }
  if (endpointCreateBody.EdgeCheckinInterval !== undefined) {
    formData.append(
      'EdgeCheckinInterval',
      endpointCreateBody.EdgeCheckinInterval.toString()
    );
  }
  formData.append(
    'EdgeTunnelServerAddress',
    endpointCreateBody.EdgeTunnelServerAddress
  );
  if (endpointCreateBody.EdgeAsyncMode !== undefined) {
    formData.append(
      'EdgeAsyncMode',
      endpointCreateBody.EdgeAsyncMode.toString()
    );
  }
  if (endpointCreateBody.Gpus !== undefined) {
    formData.append('Gpus', endpointCreateBody.Gpus);
  }

  return axios.post(`/endpoints`, formData, options);
};

export const getEndpointCreateMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointCreate>>,
    TError,
    { data: EndpointCreateBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointCreate>>,
  TError,
  { data: EndpointCreateBody },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointCreate>>,
    { data: EndpointCreateBody }
  > = (props) => {
    const { data } = props ?? {};

    return endpointCreate(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EndpointCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointCreate>>
>;
export type EndpointCreateMutationBody = EndpointCreateBody;
export type EndpointCreateMutationError = AxiosError<void>;

export const useEndpointCreate = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointCreate>>,
    TError,
    { data: EndpointCreateBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Remove an environment(endpoint).
 **Access policy**: administrator
 * @summary Remove an environment(endpoint)
 */
export const endpointDelete = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => axios.delete(`/endpoints/${id}`, options);

export const getEndpointDeleteMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointDelete>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointDelete>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointDelete>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return endpointDelete(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EndpointDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointDelete>>
>;

export type EndpointDeleteMutationError = AxiosError<unknown>;

export const useEndpointDelete = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointDelete>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointDeleteMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Retrieve details about an environment(endpoint).
 **Access policy**: restricted
 * @summary Inspect an environment(endpoint)
 */
export const endpointInspect = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeEndpoint>> =>
  axios.get(`/endpoints/${id}`, options);

export const getEndpointInspectQueryKey = (id: number) =>
  [`/endpoints/${id}`] as const;

export const getEndpointInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof endpointInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof endpointInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof endpointInspect>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEndpointInspectQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof endpointInspect>>> = ({
    signal,
  }) => endpointInspect(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type EndpointInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof endpointInspect>>
>;
export type EndpointInspectQueryError = AxiosError<void>;

export const useEndpointInspect = <
  TData = Awaited<ReturnType<typeof endpointInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof endpointInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getEndpointInspectQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update an environment(endpoint).
 **Access policy**: authenticated
 * @summary Update an environment(endpoint)
 */
export const endpointUpdate = (
  id: number,
  endpointsEndpointUpdatePayload: EndpointsEndpointUpdatePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeEndpoint>> =>
  axios.put(`/endpoints/${id}`, endpointsEndpointUpdatePayload, options);

export const getEndpointUpdateMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointUpdate>>,
    TError,
    { id: number; data: EndpointsEndpointUpdatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointUpdate>>,
  TError,
  { id: number; data: EndpointsEndpointUpdatePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointUpdate>>,
    { id: number; data: EndpointsEndpointUpdatePayload }
  > = (props) => {
    const { id, data } = props ?? {};

    return endpointUpdate(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EndpointUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointUpdate>>
>;
export type EndpointUpdateMutationBody = EndpointsEndpointUpdatePayload;
export type EndpointUpdateMutationError = AxiosError<void>;

export const useEndpointUpdate = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointUpdate>>,
    TError,
    { id: number; data: EndpointsEndpointUpdatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * De-association an edge environment(endpoint).
 **Access policy**: administrator
 * @summary De-association an edge environment(endpoint)
 */
export const endpointAssociationDelete = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeEndpoint>> =>
  axios.put(`/endpoints/${id}/association`, undefined, options);

export const getEndpointAssociationDeleteMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointAssociationDelete>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointAssociationDelete>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointAssociationDelete>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return endpointAssociationDelete(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EndpointAssociationDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointAssociationDelete>>
>;

export type EndpointAssociationDeleteMutationError = AxiosError<void>;

export const useEndpointAssociationDelete = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointAssociationDelete>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointAssociationDeleteMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Use this environment(endpoint) to upload TLS files.
 **Access policy**: administrator
 * @summary Upload a file under a specific path on the file system of an environment (endpoint)
 */
export const postEndpointsIdDockerV2BrowsePut = (
  id: number,
  postEndpointsIdDockerV2BrowsePutBody: PostEndpointsIdDockerV2BrowsePutBody,
  params?: PostEndpointsIdDockerV2BrowsePutParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  const formData = new FormData();
  formData.append('Path', postEndpointsIdDockerV2BrowsePutBody.Path);
  formData.append('file', postEndpointsIdDockerV2BrowsePutBody.file);

  return axios.post(`/endpoints/${id}/docker/v2/browse/put`, formData, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getPostEndpointsIdDockerV2BrowsePutMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postEndpointsIdDockerV2BrowsePut>>,
    TError,
    {
      id: number;
      data: PostEndpointsIdDockerV2BrowsePutBody;
      params?: PostEndpointsIdDockerV2BrowsePutParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postEndpointsIdDockerV2BrowsePut>>,
  TError,
  {
    id: number;
    data: PostEndpointsIdDockerV2BrowsePutBody;
    params?: PostEndpointsIdDockerV2BrowsePutParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postEndpointsIdDockerV2BrowsePut>>,
    {
      id: number;
      data: PostEndpointsIdDockerV2BrowsePutBody;
      params?: PostEndpointsIdDockerV2BrowsePutParams;
    }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return postEndpointsIdDockerV2BrowsePut(id, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostEndpointsIdDockerV2BrowsePutMutationResult = NonNullable<
  Awaited<ReturnType<typeof postEndpointsIdDockerV2BrowsePut>>
>;
export type PostEndpointsIdDockerV2BrowsePutMutationBody =
  PostEndpointsIdDockerV2BrowsePutBody;
export type PostEndpointsIdDockerV2BrowsePutMutationError = AxiosError<unknown>;

export const usePostEndpointsIdDockerV2BrowsePut = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postEndpointsIdDockerV2BrowsePut>>,
    TError,
    {
      id: number;
      data: PostEndpointsIdDockerV2BrowsePutBody;
      params?: PostEndpointsIdDockerV2BrowsePutParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions =
    getPostEndpointsIdDockerV2BrowsePutMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * get docker pull limits for a docker hub registry in the environment
 **Access policy**:
 * @summary fetch docker pull limits
 */
export const endpointDockerhubStatus = (
  id: number,
  registryId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EndpointsDockerhubStatusResponse>> =>
  axios.get(`/endpoints/${id}/dockerhub/${registryId}`, options);

export const getEndpointDockerhubStatusQueryKey = (
  id: number,
  registryId: number
) => [`/endpoints/${id}/dockerhub/${registryId}`] as const;

export const getEndpointDockerhubStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof endpointDockerhubStatus>>,
  TError = AxiosError<void>
>(
  id: number,
  registryId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof endpointDockerhubStatus>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof endpointDockerhubStatus>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getEndpointDockerhubStatusQueryKey(id, registryId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof endpointDockerhubStatus>>
  > = ({ signal }) =>
    endpointDockerhubStatus(id, registryId, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!(id && registryId), ...queryOptions };
};

export type EndpointDockerhubStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof endpointDockerhubStatus>>
>;
export type EndpointDockerhubStatusQueryError = AxiosError<void>;

export const useEndpointDockerhubStatus = <
  TData = Awaited<ReturnType<typeof endpointDockerhubStatus>>,
  TError = AxiosError<void>
>(
  id: number,
  registryId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof endpointDockerhubStatus>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getEndpointDockerhubStatusQueryOptions(
    id,
    registryId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Generates a general edge key
 **Access policy**: admin
 * @summary Generate an EdgeKey
 */
export const getEndpointsIdEdgeGenerateKey = (
  id: number,
  endpointedgeGenerateKeyResponse: EndpointedgeGenerateKeyResponse,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.get(`/endpoints/${id}/edge/generate-key`, options);

export const getGetEndpointsIdEdgeGenerateKeyQueryKey = (
  id: number,
  endpointedgeGenerateKeyResponse: EndpointedgeGenerateKeyResponse
) =>
  [
    `/endpoints/${id}/edge/generate-key`,
    endpointedgeGenerateKeyResponse,
  ] as const;

export const getGetEndpointsIdEdgeGenerateKeyQueryOptions = <
  TData = Awaited<ReturnType<typeof getEndpointsIdEdgeGenerateKey>>,
  TError = AxiosError<unknown>
>(
  id: number,
  endpointedgeGenerateKeyResponse: EndpointedgeGenerateKeyResponse,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getEndpointsIdEdgeGenerateKey>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof getEndpointsIdEdgeGenerateKey>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetEndpointsIdEdgeGenerateKeyQueryKey(
      id,
      endpointedgeGenerateKeyResponse
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEndpointsIdEdgeGenerateKey>>
  > = ({ signal }) =>
    getEndpointsIdEdgeGenerateKey(id, endpointedgeGenerateKeyResponse, {
      signal,
      ...axiosOptions,
    });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type GetEndpointsIdEdgeGenerateKeyQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEndpointsIdEdgeGenerateKey>>
>;
export type GetEndpointsIdEdgeGenerateKeyQueryError = AxiosError<unknown>;

export const useGetEndpointsIdEdgeGenerateKey = <
  TData = Awaited<ReturnType<typeof getEndpointsIdEdgeGenerateKey>>,
  TError = AxiosError<unknown>
>(
  id: number,
  endpointedgeGenerateKeyResponse: EndpointedgeGenerateKeyResponse,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getEndpointsIdEdgeGenerateKey>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetEndpointsIdEdgeGenerateKeyQueryOptions(
    id,
    endpointedgeGenerateKeyResponse,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * **Access policy**: public
 * @summary Inspect an EdgeJob Log
 */
export const postEndpointsIdEdgeJobsJobIDLogs = (
  id: number,
  jobID: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/endpoints/${id}/edge/jobs/${jobID}/logs`, undefined, options);

export const getPostEndpointsIdEdgeJobsJobIDLogsMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postEndpointsIdEdgeJobsJobIDLogs>>,
    TError,
    { id: number; jobID: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postEndpointsIdEdgeJobsJobIDLogs>>,
  TError,
  { id: number; jobID: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postEndpointsIdEdgeJobsJobIDLogs>>,
    { id: number; jobID: number }
  > = (props) => {
    const { id, jobID } = props ?? {};

    return postEndpointsIdEdgeJobsJobIDLogs(id, jobID, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostEndpointsIdEdgeJobsJobIDLogsMutationResult = NonNullable<
  Awaited<ReturnType<typeof postEndpointsIdEdgeJobsJobIDLogs>>
>;

export type PostEndpointsIdEdgeJobsJobIDLogsMutationError = AxiosError<unknown>;

export const usePostEndpointsIdEdgeJobsJobIDLogs = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postEndpointsIdEdgeJobsJobIDLogs>>,
    TError,
    { id: number; jobID: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions =
    getPostEndpointsIdEdgeJobsJobIDLogsMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * **Access policy**: public
 * @summary Inspect an Edge Stack for an Environment(Endpoint)
 */
export const getEndpointsIdEdgeStacksStackId = (
  id: number,
  stackId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EndpointedgeConfigResponse>> =>
  axios.get(`/endpoints/${id}/edge/stacks/${stackId}`, options);

export const getGetEndpointsIdEdgeStacksStackIdQueryKey = (
  id: number,
  stackId: number
) => [`/endpoints/${id}/edge/stacks/${stackId}`] as const;

export const getGetEndpointsIdEdgeStacksStackIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getEndpointsIdEdgeStacksStackId>>,
  TError = AxiosError<void>
>(
  id: number,
  stackId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getEndpointsIdEdgeStacksStackId>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof getEndpointsIdEdgeStacksStackId>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetEndpointsIdEdgeStacksStackIdQueryKey(id, stackId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEndpointsIdEdgeStacksStackId>>
  > = ({ signal }) =>
    getEndpointsIdEdgeStacksStackId(id, stackId, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!(id && stackId), ...queryOptions };
};

export type GetEndpointsIdEdgeStacksStackIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEndpointsIdEdgeStacksStackId>>
>;
export type GetEndpointsIdEdgeStacksStackIdQueryError = AxiosError<void>;

export const useGetEndpointsIdEdgeStacksStackId = <
  TData = Awaited<ReturnType<typeof getEndpointsIdEdgeStacksStackId>>,
  TError = AxiosError<void>
>(
  id: number,
  stackId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getEndpointsIdEdgeStacksStackId>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetEndpointsIdEdgeStacksStackIdQueryOptions(
    id,
    stackId,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * environment(endpoint) for edge agent to check status of environment(endpoint)
 **Access policy**: restricted only to Edge environments(endpoints)
 * @summary Get environment(endpoint) status
 */
export const endpointEdgeStatusInspect = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EndpointedgeEndpointEdgeStatusInspectResponse>> =>
  axios.get(`/endpoints/${id}/edge/status`, options);

export const getEndpointEdgeStatusInspectQueryKey = (id: number) =>
  [`/endpoints/${id}/edge/status`] as const;

export const getEndpointEdgeStatusInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof endpointEdgeStatusInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof endpointEdgeStatusInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof endpointEdgeStatusInspect>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEndpointEdgeStatusInspectQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof endpointEdgeStatusInspect>>
  > = ({ signal }) =>
    endpointEdgeStatusInspect(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type EndpointEdgeStatusInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof endpointEdgeStatusInspect>>
>;
export type EndpointEdgeStatusInspectQueryError = AxiosError<void>;

export const useEndpointEdgeStatusInspect = <
  TData = Awaited<ReturnType<typeof endpointEdgeStatusInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof endpointEdgeStatusInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getEndpointEdgeStatusInspectQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * **Access policy**: admin
 * @summary Trust an edge device
 */
export const postEndpointsIdEdgeTrust = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/endpoints/${id}/edge/trust`, undefined, options);

export const getPostEndpointsIdEdgeTrustMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postEndpointsIdEdgeTrust>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postEndpointsIdEdgeTrust>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postEndpointsIdEdgeTrust>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return postEndpointsIdEdgeTrust(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostEndpointsIdEdgeTrustMutationResult = NonNullable<
  Awaited<ReturnType<typeof postEndpointsIdEdgeTrust>>
>;

export type PostEndpointsIdEdgeTrustMutationError = AxiosError<unknown>;

export const usePostEndpointsIdEdgeTrust = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postEndpointsIdEdgeTrust>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getPostEndpointsIdEdgeTrustMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * force update a docker service
 **Access policy**: authenticated
 * @summary force update a docker service
 */
export const endpointForceUpdateService = (
  id: number,
  endpointsForceUpdateServicePayload: EndpointsForceUpdateServicePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<TypesServiceUpdateResponse>> =>
  axios.put(
    `/endpoints/${id}/forceupdateservice`,
    endpointsForceUpdateServicePayload,
    options
  );

export const getEndpointForceUpdateServiceMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointForceUpdateService>>,
    TError,
    { id: number; data: EndpointsForceUpdateServicePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointForceUpdateService>>,
  TError,
  { id: number; data: EndpointsForceUpdateServicePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointForceUpdateService>>,
    { id: number; data: EndpointsForceUpdateServicePayload }
  > = (props) => {
    const { id, data } = props ?? {};

    return endpointForceUpdateService(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EndpointForceUpdateServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointForceUpdateService>>
>;
export type EndpointForceUpdateServiceMutationBody =
  EndpointsForceUpdateServicePayload;
export type EndpointForceUpdateServiceMutationError = AxiosError<void>;

export const useEndpointForceUpdateService = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointForceUpdateService>>,
    TError,
    { id: number; data: EndpointsForceUpdateServicePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointForceUpdateServiceMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * update the access on the resource pool in the current environment
 **Access policy**: restricted
 * @summary update resource pool access
 */
export const endpointPoolsAccessUpdate = (
  id: number,
  rpn: number,
  endpointsResourcePoolUpdatePayload: EndpointsResourcePoolUpdatePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.put(
    `/endpoints/${id}/pools/${rpn}/access`,
    endpointsResourcePoolUpdatePayload,
    options
  );

export const getEndpointPoolsAccessUpdateMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointPoolsAccessUpdate>>,
    TError,
    { id: number; rpn: number; data: EndpointsResourcePoolUpdatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointPoolsAccessUpdate>>,
  TError,
  { id: number; rpn: number; data: EndpointsResourcePoolUpdatePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointPoolsAccessUpdate>>,
    { id: number; rpn: number; data: EndpointsResourcePoolUpdatePayload }
  > = (props) => {
    const { id, rpn, data } = props ?? {};

    return endpointPoolsAccessUpdate(id, rpn, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EndpointPoolsAccessUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointPoolsAccessUpdate>>
>;
export type EndpointPoolsAccessUpdateMutationBody =
  EndpointsResourcePoolUpdatePayload;
export type EndpointPoolsAccessUpdateMutationError = AxiosError<unknown>;

export const useEndpointPoolsAccessUpdate = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointPoolsAccessUpdate>>,
    TError,
    { id: number; rpn: number; data: EndpointsResourcePoolUpdatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointPoolsAccessUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * List all registries based on the current user authorizations in current environment.
 **Access policy**: authenticated
 * @summary List Registries on environment
 */
export const endpointRegistriesList = (
  id: number,
  params?: EndpointRegistriesListParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeRegistry[]>> =>
  axios.get(`/endpoints/${id}/registries`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getEndpointRegistriesListQueryKey = (
  id: number,
  params?: EndpointRegistriesListParams
) => [`/endpoints/${id}/registries`, ...(params ? [params] : [])] as const;

export const getEndpointRegistriesListQueryOptions = <
  TData = Awaited<ReturnType<typeof endpointRegistriesList>>,
  TError = AxiosError<void>
>(
  id: number,
  params?: EndpointRegistriesListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof endpointRegistriesList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof endpointRegistriesList>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getEndpointRegistriesListQueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof endpointRegistriesList>>
  > = ({ signal }) =>
    endpointRegistriesList(id, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type EndpointRegistriesListQueryResult = NonNullable<
  Awaited<ReturnType<typeof endpointRegistriesList>>
>;
export type EndpointRegistriesListQueryError = AxiosError<void>;

export const useEndpointRegistriesList = <
  TData = Awaited<ReturnType<typeof endpointRegistriesList>>,
  TError = AxiosError<void>
>(
  id: number,
  params?: EndpointRegistriesListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof endpointRegistriesList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getEndpointRegistriesListQueryOptions(
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * **Access policy**: authenticated
 * @summary update registry access for environment
 */
export const endpointRegistryAccess = (
  id: number,
  registryId: number,
  endpointsRegistryAccessPayload: EndpointsRegistryAccessPayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.put(
    `/endpoints/${id}/registries/${registryId}`,
    endpointsRegistryAccessPayload,
    options
  );

export const getEndpointRegistryAccessMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointRegistryAccess>>,
    TError,
    { id: number; registryId: number; data: EndpointsRegistryAccessPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointRegistryAccess>>,
  TError,
  { id: number; registryId: number; data: EndpointsRegistryAccessPayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointRegistryAccess>>,
    { id: number; registryId: number; data: EndpointsRegistryAccessPayload }
  > = (props) => {
    const { id, registryId, data } = props ?? {};

    return endpointRegistryAccess(id, registryId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EndpointRegistryAccessMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointRegistryAccess>>
>;
export type EndpointRegistryAccessMutationBody = EndpointsRegistryAccessPayload;
export type EndpointRegistryAccessMutationError = AxiosError<unknown>;

export const useEndpointRegistryAccess = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointRegistryAccess>>,
    TError,
    { id: number; registryId: number; data: EndpointsRegistryAccessPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointRegistryAccessMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Update settings for an environment(endpoint).
 **Access policy**: authenticated
 * @summary Update settings for an environment(endpoint)
 */
export const endpointSettingsUpdate = (
  id: number,
  endpointsEndpointSettingsUpdatePayload: EndpointsEndpointSettingsUpdatePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeEndpoint>> =>
  axios.put(
    `/endpoints/${id}/settings`,
    endpointsEndpointSettingsUpdatePayload,
    options
  );

export const getEndpointSettingsUpdateMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointSettingsUpdate>>,
    TError,
    { id: number; data: EndpointsEndpointSettingsUpdatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointSettingsUpdate>>,
  TError,
  { id: number; data: EndpointsEndpointSettingsUpdatePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointSettingsUpdate>>,
    { id: number; data: EndpointsEndpointSettingsUpdatePayload }
  > = (props) => {
    const { id, data } = props ?? {};

    return endpointSettingsUpdate(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EndpointSettingsUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointSettingsUpdate>>
>;
export type EndpointSettingsUpdateMutationBody =
  EndpointsEndpointSettingsUpdatePayload;
export type EndpointSettingsUpdateMutationError = AxiosError<void>;

export const useEndpointSettingsUpdate = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointSettingsUpdate>>,
    TError,
    { id: number; data: EndpointsEndpointSettingsUpdatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointSettingsUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Snapshots an environment(endpoint)
 **Access policy**: administrator
 * @summary Snapshots an environment(endpoint)
 */
export const endpointSnapshot = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/endpoints/${id}/snapshot`, undefined, options);

export const getEndpointSnapshotMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointSnapshot>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointSnapshot>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointSnapshot>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return endpointSnapshot(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EndpointSnapshotMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointSnapshot>>
>;

export type EndpointSnapshotMutationError = AxiosError<unknown>;

export const useEndpointSnapshot = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointSnapshot>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointSnapshotMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Environment(Endpoint) for edge agent to check status of environment(endpoint)
 **Access policy**: restricted only to Edge environments(endpoints)
 * @summary Get environment(endpoint) status
 */
export const endpointEdgeAsync = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EndpointedgeEdgeAsyncResponse>> =>
  axios.post(`/endpoints/edge/async`, undefined, options);

export const getEndpointEdgeAsyncMutationOptions = <
  TError = AxiosError<void>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointEdgeAsync>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointEdgeAsync>>,
  TError,
  TVariables,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointEdgeAsync>>,
    TVariables
  > = () => endpointEdgeAsync(axiosOptions);

  return { mutationFn, ...mutationOptions };
};

export type EndpointEdgeAsyncMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointEdgeAsync>>
>;

export type EndpointEdgeAsyncMutationError = AxiosError<void>;

export const useEndpointEdgeAsync = <
  TError = AxiosError<void>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointEdgeAsync>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointEdgeAsyncMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Create or retrieve the endpoint for an EdgeID
 */
export const endpointCreateGlobalKey = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<EndpointsEndpointCreateGlobalKeyResponse>> =>
  axios.post(`/endpoints/global-key`, undefined, options);

export const getEndpointCreateGlobalKeyMutationOptions = <
  TError = AxiosError<void>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointCreateGlobalKey>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointCreateGlobalKey>>,
  TError,
  TVariables,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointCreateGlobalKey>>,
    TVariables
  > = () => endpointCreateGlobalKey(axiosOptions);

  return { mutationFn, ...mutationOptions };
};

export type EndpointCreateGlobalKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointCreateGlobalKey>>
>;

export type EndpointCreateGlobalKeyMutationError = AxiosError<void>;

export const useEndpointCreateGlobalKey = <
  TError = AxiosError<void>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointCreateGlobalKey>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointCreateGlobalKeyMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Snapshot all environments(endpoints)
 **Access policy**: administrator
 * @summary Snapshot all environment(endpoint)
 */
export const endpointSnapshots = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/endpoints/snapshot`, undefined, options);

export const getEndpointSnapshotsMutationOptions = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointSnapshots>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endpointSnapshots>>,
  TError,
  TVariables,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endpointSnapshots>>,
    TVariables
  > = () => endpointSnapshots(axiosOptions);

  return { mutationFn, ...mutationOptions };
};

export type EndpointSnapshotsMutationResult = NonNullable<
  Awaited<ReturnType<typeof endpointSnapshots>>
>;

export type EndpointSnapshotsMutationError = AxiosError<unknown>;

export const useEndpointSnapshots = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endpointSnapshots>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getEndpointSnapshotsMutationOptions(options);

  return useMutation(mutationOptions);
};
