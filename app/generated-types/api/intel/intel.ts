/**
 * Generated by orval v6.15.0 üç∫
 * Do not edit manually.
 * PortainerEE API
 * Portainer API is an HTTP API served by Portainer. It is used by the Portainer UI and everything you can do with the UI can be done using the HTTP API.
Examples are available at https://documentation.portainer.io/api/api-examples/
You can find out more about Portainer at [http://portainer.io](http://portainer.io) and get some support on [Slack](http://portainer.io/slack/).

# Authentication

Most of the API environments(endpoints) require to be authenticated as well as some level of authorization to be used.
Portainer API uses JSON Web Token to manage authentication and thus requires you to provide a token in the **Authorization** header of each request
with the **Bearer** authentication mechanism.

Example:

```
Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsInJvbGUiOjEsImV4cCI6MTQ5OTM3NjE1NH0.NJ6vE8FY1WG6jsRQzfMqeatJ4vh2TWAeeYfDhP71YEE
```

# Security

Each API environment(endpoint) has an associated access policy, it is documented in the description of each environment(endpoint).

Different access policies are available:

- Public access
- Authenticated access
- Restricted access
- Administrator access

### Public access

No authentication is required to access the environments(endpoints) with this access policy.

### Authenticated access

Authentication is required to access the environments(endpoints) with this access policy.

### Restricted access

Authentication is required to access the environments(endpoints) with this access policy.
Extra-checks might be added to ensure access to the resource is granted. Returned data might also be filtered.

### Administrator access

Authentication as well as an administrator role are required to access the environments(endpoints) with this access policy.

# Execute Docker requests

Portainer **DO NOT** expose specific environments(endpoints) to manage your Docker resources (create a container, remove a volume, etc...).

Instead, it acts as a reverse-proxy to the Docker HTTP API. This means that you can execute Docker requests **via** the Portainer HTTP API.

To do so, you can use the `/endpoints/{id}/docker` Portainer API environment(endpoint) (which is not documented below due to Swagger limitations). This environment(endpoint) has a restricted access policy so you still need to be authenticated to be able to query this environment(endpoint). Any query on this environment(endpoint) will be proxied to the Docker API of the associated environment(endpoint) (requests and responses objects are the same as documented in the Docker API).

# Private Registry

Using private registry, you will need to pass a based64 encoded JSON string ‚Äò{"registryId":\<registryID value\>}‚Äô inside the Request Header. The parameter name is "X-Registry-Auth".
\<registryID value\> - The registry ID where the repository was created.

Example:

```
eyJyZWdpc3RyeUlkIjoxfQ==
```

**NOTE**: You can find more information on how to query the Docker API in the [Docker official documentation](https://docs.docker.com/engine/api/v1.30/) as well as in [this Portainer example](https://documentation.portainer.io/api/api-examples/).

 * OpenAPI spec version: 2.19.0
 */
import axios from 'axios';
import type { AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { useQuery, useMutation } from 'react-query';
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from 'react-query';

import type {
  FdoFdoConfigurePayload,
  FdoDeviceConfigurePayload,
  OpenamtOpenAMTConfigurePayload,
  OpenamtDeviceActionPayload,
  OpenamtDeviceFeaturesPayload,
} from '../portainerEEAPI.schemas';

/**
 * Enable Portainer's FDO capabilities
 **Access policy**: administrator
 * @summary Enable Portainer's FDO capabilities
 */
export const fdoConfigure = (
  fdoFdoConfigurePayload: FdoFdoConfigurePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/fdo`, fdoFdoConfigurePayload, options);

export const getFdoConfigureMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fdoConfigure>>,
    TError,
    { data: FdoFdoConfigurePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof fdoConfigure>>,
  TError,
  { data: FdoFdoConfigurePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof fdoConfigure>>,
    { data: FdoFdoConfigurePayload }
  > = (props) => {
    const { data } = props ?? {};

    return fdoConfigure(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FdoConfigureMutationResult = NonNullable<
  Awaited<ReturnType<typeof fdoConfigure>>
>;
export type FdoConfigureMutationBody = FdoFdoConfigurePayload;
export type FdoConfigureMutationError = AxiosError<unknown>;

export const useFdoConfigure = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fdoConfigure>>,
    TError,
    { data: FdoFdoConfigurePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getFdoConfigureMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * configures an FDO device
 **Access policy**: administrator
 * @summary configures an FDO device
 */
export const fdoConfigureDevice = (
  guid: number,
  fdoDeviceConfigurePayload: FdoDeviceConfigurePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/fdo/configure/${guid}`, fdoDeviceConfigurePayload, options);

export const getFdoConfigureDeviceMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fdoConfigureDevice>>,
    TError,
    { guid: number; data: FdoDeviceConfigurePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof fdoConfigureDevice>>,
  TError,
  { guid: number; data: FdoDeviceConfigurePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof fdoConfigureDevice>>,
    { guid: number; data: FdoDeviceConfigurePayload }
  > = (props) => {
    const { guid, data } = props ?? {};

    return fdoConfigureDevice(guid, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FdoConfigureDeviceMutationResult = NonNullable<
  Awaited<ReturnType<typeof fdoConfigureDevice>>
>;
export type FdoConfigureDeviceMutationBody = FdoDeviceConfigurePayload;
export type FdoConfigureDeviceMutationError = AxiosError<unknown>;

export const useFdoConfigureDevice = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fdoConfigureDevice>>,
    TError,
    { guid: number; data: FdoDeviceConfigurePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getFdoConfigureDeviceMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * List all known FDO vouchers
 **Access policy**: administrator
 * @summary List all known FDO vouchers
 */
export const fdoListAll = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => axios.get(`/fdo/list`, options);

export const getFdoListAllQueryKey = () => [`/fdo/list`] as const;

export const getFdoListAllQueryOptions = <
  TData = Awaited<ReturnType<typeof fdoListAll>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof fdoListAll>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryOptions<Awaited<ReturnType<typeof fdoListAll>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFdoListAllQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof fdoListAll>>> = ({
    signal,
  }) => fdoListAll({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions };
};

export type FdoListAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof fdoListAll>>
>;
export type FdoListAllQueryError = AxiosError<unknown>;

export const useFdoListAll = <
  TData = Awaited<ReturnType<typeof fdoListAll>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof fdoListAll>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFdoListAllQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * retrieves all FDO profiles
 **Access policy**: administrator
 * @summary retrieves all FDO profiles
 */
export const fdoProfileList = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => axios.get(`/fdo/profiles`, options);

export const getFdoProfileListQueryKey = () => [`/fdo/profiles`] as const;

export const getFdoProfileListQueryOptions = <
  TData = Awaited<ReturnType<typeof fdoProfileList>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof fdoProfileList>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryOptions<
  Awaited<ReturnType<typeof fdoProfileList>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFdoProfileListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof fdoProfileList>>> = ({
    signal,
  }) => fdoProfileList({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions };
};

export type FdoProfileListQueryResult = NonNullable<
  Awaited<ReturnType<typeof fdoProfileList>>
>;
export type FdoProfileListQueryError = AxiosError<unknown>;

export const useFdoProfileList = <
  TData = Awaited<ReturnType<typeof fdoProfileList>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof fdoProfileList>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFdoProfileListQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * creates a new FDO Profile
 **Access policy**: administrator
 * @summary creates a new FDO Profile
 */
export const createProfile = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/fdo/profiles`, undefined, options);

export const getCreateProfileMutationOptions = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProfile>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProfile>>,
  TError,
  TVariables,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProfile>>,
    TVariables
  > = () => createProfile(axiosOptions);

  return { mutationFn, ...mutationOptions };
};

export type CreateProfileMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProfile>>
>;

export type CreateProfileMutationError = AxiosError<unknown>;

export const useCreateProfile = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProfile>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getCreateProfileMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * deletes a FDO Profile
 **Access policy**: administrator
 * @summary deletes a FDO Profile
 */
export const deleteProfile = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => axios.delete(`/fdo/profiles/${id}`, options);

export const getDeleteProfileMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProfile>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProfile>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProfile>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return deleteProfile(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProfileMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProfile>>
>;

export type DeleteProfileMutationError = AxiosError<unknown>;

export const useDeleteProfile = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProfile>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getDeleteProfileMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * retrieves a given FDO profile information and content
 **Access policy**: administrator
 * @summary retrieves a given FDO profile information and content
 */
export const fdoProfileInspect = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => axios.get(`/fdo/profiles/${id}`, options);

export const getFdoProfileInspectQueryKey = (id: number) =>
  [`/fdo/profiles/${id}`] as const;

export const getFdoProfileInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof fdoProfileInspect>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof fdoProfileInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof fdoProfileInspect>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFdoProfileInspectQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fdoProfileInspect>>
  > = ({ signal }) => fdoProfileInspect(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type FdoProfileInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof fdoProfileInspect>>
>;
export type FdoProfileInspectQueryError = AxiosError<unknown>;

export const useFdoProfileInspect = <
  TData = Awaited<ReturnType<typeof fdoProfileInspect>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof fdoProfileInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFdoProfileInspectQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * updates an existing FDO Profile
 **Access policy**: administrator
 * @summary updates an existing FDO Profile
 */
export const updateProfile = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.put(`/fdo/profiles/${id}`, undefined, options);

export const getUpdateProfileMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProfile>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProfile>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProfile>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return updateProfile(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProfileMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProfile>>
>;

export type UpdateProfileMutationError = AxiosError<unknown>;

export const useUpdateProfile = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProfile>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUpdateProfileMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * duplicated an existing FDO Profile
 **Access policy**: administrator
 * @summary duplicated an existing FDO Profile
 */
export const duplicate = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/fdo/profiles/${id}/duplicate`, undefined, options);

export const getDuplicateMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof duplicate>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof duplicate>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof duplicate>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return duplicate(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DuplicateMutationResult = NonNullable<
  Awaited<ReturnType<typeof duplicate>>
>;

export type DuplicateMutationError = AxiosError<unknown>;

export const useDuplicate = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof duplicate>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getDuplicateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * register an FDO device
 **Access policy**: administrator
 * @summary register an FDO device
 */
export const fdoRegisterDevice = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/fdo/register`, undefined, options);

export const getFdoRegisterDeviceMutationOptions = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fdoRegisterDevice>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof fdoRegisterDevice>>,
  TError,
  TVariables,
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof fdoRegisterDevice>>,
    TVariables
  > = () => fdoRegisterDevice(axiosOptions);

  return { mutationFn, ...mutationOptions };
};

export type FdoRegisterDeviceMutationResult = NonNullable<
  Awaited<ReturnType<typeof fdoRegisterDevice>>
>;

export type FdoRegisterDeviceMutationError = AxiosError<unknown>;

export const useFdoRegisterDevice = <
  TError = AxiosError<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fdoRegisterDevice>>,
    TError,
    TVariables,
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getFdoRegisterDeviceMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Enable Portainer's OpenAMT capabilities
 **Access policy**: administrator
 * @summary Enable Portainer's OpenAMT capabilities
 */
export const openAMTConfigure = (
  openamtOpenAMTConfigurePayload: OpenamtOpenAMTConfigurePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/open_amt`, openamtOpenAMTConfigurePayload, options);

export const getOpenAMTConfigureMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof openAMTConfigure>>,
    TError,
    { data: OpenamtOpenAMTConfigurePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof openAMTConfigure>>,
  TError,
  { data: OpenamtOpenAMTConfigurePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof openAMTConfigure>>,
    { data: OpenamtOpenAMTConfigurePayload }
  > = (props) => {
    const { data } = props ?? {};

    return openAMTConfigure(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OpenAMTConfigureMutationResult = NonNullable<
  Awaited<ReturnType<typeof openAMTConfigure>>
>;
export type OpenAMTConfigureMutationBody = OpenamtOpenAMTConfigurePayload;
export type OpenAMTConfigureMutationError = AxiosError<unknown>;

export const useOpenAMTConfigure = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof openAMTConfigure>>,
    TError,
    { data: OpenamtOpenAMTConfigurePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getOpenAMTConfigureMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Activate OpenAMT device and associate to agent endpoint
 **Access policy**: administrator
 * @summary Activate OpenAMT device and associate to agent endpoint
 */
export const openAMTActivate = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/open_amt/${id}/activate`, undefined, options);

export const getOpenAMTActivateMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof openAMTActivate>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof openAMTActivate>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof openAMTActivate>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return openAMTActivate(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type OpenAMTActivateMutationResult = NonNullable<
  Awaited<ReturnType<typeof openAMTActivate>>
>;

export type OpenAMTActivateMutationError = AxiosError<unknown>;

export const useOpenAMTActivate = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof openAMTActivate>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getOpenAMTActivateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Fetch OpenAMT managed devices information for endpoint
 **Access policy**: administrator
 * @summary Fetch OpenAMT managed devices information for endpoint
 */
export const openAMTDevices = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.get(`/open_amt/${id}/devices`, options);

export const getOpenAMTDevicesQueryKey = (id: number) =>
  [`/open_amt/${id}/devices`] as const;

export const getOpenAMTDevicesQueryOptions = <
  TData = Awaited<ReturnType<typeof openAMTDevices>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof openAMTDevices>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof openAMTDevices>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOpenAMTDevicesQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof openAMTDevices>>> = ({
    signal,
  }) => openAMTDevices(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type OpenAMTDevicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof openAMTDevices>>
>;
export type OpenAMTDevicesQueryError = AxiosError<unknown>;

export const useOpenAMTDevices = <
  TData = Awaited<ReturnType<typeof openAMTDevices>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof openAMTDevices>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getOpenAMTDevicesQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Execute out of band action on an AMT managed device
 **Access policy**: administrator
 * @summary Execute out of band action on an AMT managed device
 */
export const deviceAction = (
  id: number,
  deviceId: number,
  openamtDeviceActionPayload: OpenamtDeviceActionPayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(
    `/open_amt/${id}/devices/${deviceId}/action`,
    openamtDeviceActionPayload,
    options
  );

export const getDeviceActionMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deviceAction>>,
    TError,
    { id: number; deviceId: number; data: OpenamtDeviceActionPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deviceAction>>,
  TError,
  { id: number; deviceId: number; data: OpenamtDeviceActionPayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deviceAction>>,
    { id: number; deviceId: number; data: OpenamtDeviceActionPayload }
  > = (props) => {
    const { id, deviceId, data } = props ?? {};

    return deviceAction(id, deviceId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeviceActionMutationResult = NonNullable<
  Awaited<ReturnType<typeof deviceAction>>
>;
export type DeviceActionMutationBody = OpenamtDeviceActionPayload;
export type DeviceActionMutationError = AxiosError<unknown>;

export const useDeviceAction = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deviceAction>>,
    TError,
    { id: number; deviceId: number; data: OpenamtDeviceActionPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getDeviceActionMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Enable features on an AMT managed device
 **Access policy**: administrator
 * @summary Enable features on an AMT managed device
 */
export const deviceFeatures = (
  id: number,
  deviceId: number,
  openamtDeviceFeaturesPayload: OpenamtDeviceFeaturesPayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(
    `/open_amt/${id}/devices_features/${deviceId}`,
    openamtDeviceFeaturesPayload,
    options
  );

export const getDeviceFeaturesMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deviceFeatures>>,
    TError,
    { id: number; deviceId: number; data: OpenamtDeviceFeaturesPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deviceFeatures>>,
  TError,
  { id: number; deviceId: number; data: OpenamtDeviceFeaturesPayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deviceFeatures>>,
    { id: number; deviceId: number; data: OpenamtDeviceFeaturesPayload }
  > = (props) => {
    const { id, deviceId, data } = props ?? {};

    return deviceFeatures(id, deviceId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeviceFeaturesMutationResult = NonNullable<
  Awaited<ReturnType<typeof deviceFeatures>>
>;
export type DeviceFeaturesMutationBody = OpenamtDeviceFeaturesPayload;
export type DeviceFeaturesMutationError = AxiosError<unknown>;

export const useDeviceFeatures = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deviceFeatures>>,
    TError,
    { id: number; deviceId: number; data: OpenamtDeviceFeaturesPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getDeviceFeaturesMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Request OpenAMT info from a node
 **Access policy**: administrator
 * @summary Request OpenAMT info from a node
 */
export const openAMTHostInfo = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => axios.get(`/open_amt/${id}/info`, options);

export const getOpenAMTHostInfoQueryKey = (id: number) =>
  [`/open_amt/${id}/info`] as const;

export const getOpenAMTHostInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof openAMTHostInfo>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof openAMTHostInfo>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof openAMTHostInfo>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getOpenAMTHostInfoQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof openAMTHostInfo>>> = ({
    signal,
  }) => openAMTHostInfo(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type OpenAMTHostInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof openAMTHostInfo>>
>;
export type OpenAMTHostInfoQueryError = AxiosError<unknown>;

export const useOpenAMTHostInfo = <
  TData = Awaited<ReturnType<typeof openAMTHostInfo>>,
  TError = AxiosError<unknown>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof openAMTHostInfo>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getOpenAMTHostInfoQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};
