/**
 * Generated by orval v6.15.0 üç∫
 * Do not edit manually.
 * PortainerEE API
 * Portainer API is an HTTP API served by Portainer. It is used by the Portainer UI and everything you can do with the UI can be done using the HTTP API.
Examples are available at https://documentation.portainer.io/api/api-examples/
You can find out more about Portainer at [http://portainer.io](http://portainer.io) and get some support on [Slack](http://portainer.io/slack/).

# Authentication

Most of the API environments(endpoints) require to be authenticated as well as some level of authorization to be used.
Portainer API uses JSON Web Token to manage authentication and thus requires you to provide a token in the **Authorization** header of each request
with the **Bearer** authentication mechanism.

Example:

```
Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsInJvbGUiOjEsImV4cCI6MTQ5OTM3NjE1NH0.NJ6vE8FY1WG6jsRQzfMqeatJ4vh2TWAeeYfDhP71YEE
```

# Security

Each API environment(endpoint) has an associated access policy, it is documented in the description of each environment(endpoint).

Different access policies are available:

- Public access
- Authenticated access
- Restricted access
- Administrator access

### Public access

No authentication is required to access the environments(endpoints) with this access policy.

### Authenticated access

Authentication is required to access the environments(endpoints) with this access policy.

### Restricted access

Authentication is required to access the environments(endpoints) with this access policy.
Extra-checks might be added to ensure access to the resource is granted. Returned data might also be filtered.

### Administrator access

Authentication as well as an administrator role are required to access the environments(endpoints) with this access policy.

# Execute Docker requests

Portainer **DO NOT** expose specific environments(endpoints) to manage your Docker resources (create a container, remove a volume, etc...).

Instead, it acts as a reverse-proxy to the Docker HTTP API. This means that you can execute Docker requests **via** the Portainer HTTP API.

To do so, you can use the `/endpoints/{id}/docker` Portainer API environment(endpoint) (which is not documented below due to Swagger limitations). This environment(endpoint) has a restricted access policy so you still need to be authenticated to be able to query this environment(endpoint). Any query on this environment(endpoint) will be proxied to the Docker API of the associated environment(endpoint) (requests and responses objects are the same as documented in the Docker API).

# Private Registry

Using private registry, you will need to pass a based64 encoded JSON string ‚Äò{"registryId":\<registryID value\>}‚Äô inside the Request Header. The parameter name is "X-Registry-Auth".
\<registryID value\> - The registry ID where the repository was created.

Example:

```
eyJyZWdpc3RyeUlkIjoxfQ==
```

**NOTE**: You can find more information on how to query the Docker API in the [Docker official documentation](https://docs.docker.com/engine/api/v1.30/) as well as in [this Portainer example](https://documentation.portainer.io/api/api-examples/).

 * OpenAPI spec version: 2.19.0
 */
import axios from 'axios';
import type { AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { useQuery, useMutation } from 'react-query';
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from 'react-query';

import type {
  PortainereeStack,
  StackListParams,
  StackDeleteParams,
  StacksUpdateSwarmStackPayload,
  StackUpdateParams,
  StackAssociateParams,
  StacksStackFileResponse,
  StacksStackGitUpdatePayload,
  StackUpdateGitParams,
  StacksStackGitRedployPayload,
  StackGitRedeployParams,
  StacksStackMigratePayload,
  StackMigrateParams,
  StacksKubernetesGitDeploymentPayload,
  StackCreateKubernetesGitParams,
  StacksKubernetesStringDeploymentPayload,
  StackCreateKubernetesFileParams,
  StacksKubernetesManifestURLDeploymentPayload,
  StackCreateKubernetesUrlParams,
  StackCreateDockerStandaloneFileBody,
  StackCreateDockerStandaloneFileParams,
  StacksComposeStackFromGitRepositoryPayload,
  StackCreateDockerStandaloneRepositoryParams,
  StacksComposeStackFromFileContentPayload,
  StackCreateDockerStandaloneStringParams,
  StackCreateDockerSwarmFileBody,
  StackCreateDockerSwarmFileParams,
  StacksSwarmStackFromGitRepositoryPayload,
  StackCreateDockerSwarmRepositoryParams,
  StacksSwarmStackFromFileContentPayload,
  StackCreateDockerSwarmStringParams,
} from '../portainerEEAPI.schemas';

/**
 * List all stacks based on the current user authorizations.
Will return all stacks if using an administrator account otherwise it
will only return the list of stacks the user have access to.
**Access policy**: authenticated
 * @summary List stacks
 */
export const stackList = (
  params?: StackListParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack[] | void>> =>
  axios.get(`/stacks`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getStackListQueryKey = (params?: StackListParams) =>
  [`/stacks`, ...(params ? [params] : [])] as const;

export const getStackListQueryOptions = <
  TData = Awaited<ReturnType<typeof stackList>>,
  TError = AxiosError<unknown>
>(
  params?: StackListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stackList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof stackList>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getStackListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof stackList>>> = ({
    signal,
  }) => stackList(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions };
};

export type StackListQueryResult = NonNullable<
  Awaited<ReturnType<typeof stackList>>
>;
export type StackListQueryError = AxiosError<unknown>;

export const useStackList = <
  TData = Awaited<ReturnType<typeof stackList>>,
  TError = AxiosError<unknown>
>(
  params?: StackListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stackList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getStackListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Remove a stack.
 **Access policy**: restricted
 * @summary Remove a stack
 */
export const stackDelete = (
  id: number,
  params?: StackDeleteParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.delete(`/stacks/${id}`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getStackDeleteMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackDelete>>,
    TError,
    { id: number; params?: StackDeleteParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackDelete>>,
  TError,
  { id: number; params?: StackDeleteParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackDelete>>,
    { id: number; params?: StackDeleteParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return stackDelete(id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackDelete>>
>;

export type StackDeleteMutationError = AxiosError<unknown>;

export const useStackDelete = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackDelete>>,
    TError,
    { id: number; params?: StackDeleteParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackDeleteMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Retrieve details about a stack.
 **Access policy**: restricted
 * @summary Inspect a stack
 */
export const stackInspect = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.get(`/stacks/${id}`, options);

export const getStackInspectQueryKey = (id: number) =>
  [`/stacks/${id}`] as const;

export const getStackInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof stackInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stackInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof stackInspect>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getStackInspectQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof stackInspect>>> = ({
    signal,
  }) => stackInspect(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type StackInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof stackInspect>>
>;
export type StackInspectQueryError = AxiosError<void>;

export const useStackInspect = <
  TData = Awaited<ReturnType<typeof stackInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stackInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getStackInspectQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update a stack, only for file based stacks.
 **Access policy**: authenticated
 * @summary Update a stack
 */
export const stackUpdate = (
  id: number,
  stacksUpdateSwarmStackPayload: StacksUpdateSwarmStackPayload,
  params?: StackUpdateParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.put(`/stacks/${id}`, stacksUpdateSwarmStackPayload, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getStackUpdateMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackUpdate>>,
    TError,
    {
      id: number;
      data: StacksUpdateSwarmStackPayload;
      params?: StackUpdateParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackUpdate>>,
  TError,
  {
    id: number;
    data: StacksUpdateSwarmStackPayload;
    params?: StackUpdateParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackUpdate>>,
    {
      id: number;
      data: StacksUpdateSwarmStackPayload;
      params?: StackUpdateParams;
    }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return stackUpdate(id, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackUpdate>>
>;
export type StackUpdateMutationBody = StacksUpdateSwarmStackPayload;
export type StackUpdateMutationError = AxiosError<void>;

export const useStackUpdate = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackUpdate>>,
    TError,
    {
      id: number;
      data: StacksUpdateSwarmStackPayload;
      params?: StackUpdateParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * **Access policy**: administrator
 * @summary Associate an orphaned stack to a new environment(endpoint)
 */
export const stackAssociate = (
  id: number,
  params: StackAssociateParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.put(`/stacks/${id}/associate`, undefined, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getStackAssociateMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackAssociate>>,
    TError,
    { id: number; params: StackAssociateParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackAssociate>>,
  TError,
  { id: number; params: StackAssociateParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackAssociate>>,
    { id: number; params: StackAssociateParams }
  > = (props) => {
    const { id, params } = props ?? {};

    return stackAssociate(id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackAssociateMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackAssociate>>
>;

export type StackAssociateMutationError = AxiosError<void>;

export const useStackAssociate = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackAssociate>>,
    TError,
    { id: number; params: StackAssociateParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackAssociateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get Stack file content.
 **Access policy**: restricted
 * @summary Retrieve the content of the Stack file for the specified stack
 */
export const stackFileInspect = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<StacksStackFileResponse>> =>
  axios.get(`/stacks/${id}/file`, options);

export const getStackFileInspectQueryKey = (id: number) =>
  [`/stacks/${id}/file`] as const;

export const getStackFileInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof stackFileInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stackFileInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof stackFileInspect>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getStackFileInspectQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof stackFileInspect>>
  > = ({ signal }) => stackFileInspect(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type StackFileInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof stackFileInspect>>
>;
export type StackFileInspectQueryError = AxiosError<void>;

export const useStackFileInspect = <
  TData = Awaited<ReturnType<typeof stackFileInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof stackFileInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getStackFileInspectQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate
 **Access policy**: authenticated
 * @summary Update a stack's Git configs
 */
export const stackUpdateGit = (
  id: number,
  stacksStackGitUpdatePayload: StacksStackGitUpdatePayload,
  params?: StackUpdateGitParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.post(`/stacks/${id}/git`, stacksStackGitUpdatePayload, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getStackUpdateGitMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackUpdateGit>>,
    TError,
    {
      id: number;
      data: StacksStackGitUpdatePayload;
      params?: StackUpdateGitParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackUpdateGit>>,
  TError,
  {
    id: number;
    data: StacksStackGitUpdatePayload;
    params?: StackUpdateGitParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackUpdateGit>>,
    {
      id: number;
      data: StacksStackGitUpdatePayload;
      params?: StackUpdateGitParams;
    }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return stackUpdateGit(id, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackUpdateGitMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackUpdateGit>>
>;
export type StackUpdateGitMutationBody = StacksStackGitUpdatePayload;
export type StackUpdateGitMutationError = AxiosError<void>;

export const useStackUpdateGit = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackUpdateGit>>,
    TError,
    {
      id: number;
      data: StacksStackGitUpdatePayload;
      params?: StackUpdateGitParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackUpdateGitMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Pull and redeploy a stack via Git
 **Access policy**: authenticated
 * @summary Redeploy a stack
 */
export const stackGitRedeploy = (
  id: number,
  stacksStackGitRedployPayload: StacksStackGitRedployPayload,
  params?: StackGitRedeployParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.put(`/stacks/${id}/git/redeploy`, stacksStackGitRedployPayload, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getStackGitRedeployMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackGitRedeploy>>,
    TError,
    {
      id: number;
      data: StacksStackGitRedployPayload;
      params?: StackGitRedeployParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackGitRedeploy>>,
  TError,
  {
    id: number;
    data: StacksStackGitRedployPayload;
    params?: StackGitRedeployParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackGitRedeploy>>,
    {
      id: number;
      data: StacksStackGitRedployPayload;
      params?: StackGitRedeployParams;
    }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return stackGitRedeploy(id, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackGitRedeployMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackGitRedeploy>>
>;
export type StackGitRedeployMutationBody = StacksStackGitRedployPayload;
export type StackGitRedeployMutationError = AxiosError<void>;

export const useStackGitRedeploy = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackGitRedeploy>>,
    TError,
    {
      id: number;
      data: StacksStackGitRedployPayload;
      params?: StackGitRedeployParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackGitRedeployMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack.
 **Access policy**: authenticated
 * @summary Migrate a stack to another environment(endpoint)
 */
export const stackMigrate = (
  id: number,
  stacksStackMigratePayload: StacksStackMigratePayload,
  params?: StackMigrateParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.post(`/stacks/${id}/migrate`, stacksStackMigratePayload, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getStackMigrateMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackMigrate>>,
    TError,
    {
      id: number;
      data: StacksStackMigratePayload;
      params?: StackMigrateParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackMigrate>>,
  TError,
  { id: number; data: StacksStackMigratePayload; params?: StackMigrateParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackMigrate>>,
    { id: number; data: StacksStackMigratePayload; params?: StackMigrateParams }
  > = (props) => {
    const { id, data, params } = props ?? {};

    return stackMigrate(id, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackMigrateMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackMigrate>>
>;
export type StackMigrateMutationBody = StacksStackMigratePayload;
export type StackMigrateMutationError = AxiosError<void>;

export const useStackMigrate = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackMigrate>>,
    TError,
    {
      id: number;
      data: StacksStackMigratePayload;
      params?: StackMigrateParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackMigrateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Starts a stopped Stack.
 **Access policy**: authenticated
 * @summary Starts a stopped Stack
 */
export const stackStart = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.post(`/stacks/${id}/start`, undefined, options);

export const getStackStartMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackStart>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackStart>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackStart>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return stackStart(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackStartMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackStart>>
>;

export type StackStartMutationError = AxiosError<void>;

export const useStackStart = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackStart>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackStartMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Stops a stopped Stack.
 **Access policy**: authenticated
 * @summary Stops a stopped Stack
 */
export const stackStop = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.post(`/stacks/${id}/stop`, undefined, options);

export const getStackStopMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackStop>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackStop>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackStop>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return stackStop(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackStopMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackStop>>
>;

export type StackStopMutationError = AxiosError<void>;

export const useStackStop = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackStop>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackStopMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Deploy a new stack into a Docker environment specified via the environment identifier.
 **Access policy**: authenticated
 * @summary Deploy a new kubernetes stack from a git repository
 */
export const stackCreateKubernetesGit = (
  stacksKubernetesGitDeploymentPayload: StacksKubernetesGitDeploymentPayload,
  params: StackCreateKubernetesGitParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.post(
    `/stacks/create/kubernetes/repository`,
    stacksKubernetesGitDeploymentPayload,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getStackCreateKubernetesGitMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateKubernetesGit>>,
    TError,
    {
      data: StacksKubernetesGitDeploymentPayload;
      params: StackCreateKubernetesGitParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackCreateKubernetesGit>>,
  TError,
  {
    data: StacksKubernetesGitDeploymentPayload;
    params: StackCreateKubernetesGitParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackCreateKubernetesGit>>,
    {
      data: StacksKubernetesGitDeploymentPayload;
      params: StackCreateKubernetesGitParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return stackCreateKubernetesGit(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackCreateKubernetesGitMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackCreateKubernetesGit>>
>;
export type StackCreateKubernetesGitMutationBody =
  StacksKubernetesGitDeploymentPayload;
export type StackCreateKubernetesGitMutationError = AxiosError<void>;

export const useStackCreateKubernetesGit = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateKubernetesGit>>,
    TError,
    {
      data: StacksKubernetesGitDeploymentPayload;
      params: StackCreateKubernetesGitParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackCreateKubernetesGitMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Deploy a new stack into a Docker environment specified via the environment identifier.
 **Access policy**: authenticated
 * @summary Deploy a new kubernetes stack from a file
 */
export const stackCreateKubernetesFile = (
  stacksKubernetesStringDeploymentPayload: StacksKubernetesStringDeploymentPayload,
  params: StackCreateKubernetesFileParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.post(
    `/stacks/create/kubernetes/string`,
    stacksKubernetesStringDeploymentPayload,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getStackCreateKubernetesFileMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateKubernetesFile>>,
    TError,
    {
      data: StacksKubernetesStringDeploymentPayload;
      params: StackCreateKubernetesFileParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackCreateKubernetesFile>>,
  TError,
  {
    data: StacksKubernetesStringDeploymentPayload;
    params: StackCreateKubernetesFileParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackCreateKubernetesFile>>,
    {
      data: StacksKubernetesStringDeploymentPayload;
      params: StackCreateKubernetesFileParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return stackCreateKubernetesFile(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackCreateKubernetesFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackCreateKubernetesFile>>
>;
export type StackCreateKubernetesFileMutationBody =
  StacksKubernetesStringDeploymentPayload;
export type StackCreateKubernetesFileMutationError = AxiosError<void>;

export const useStackCreateKubernetesFile = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateKubernetesFile>>,
    TError,
    {
      data: StacksKubernetesStringDeploymentPayload;
      params: StackCreateKubernetesFileParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackCreateKubernetesFileMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Deploy a new stack into a Docker environment specified via the environment identifier.
 **Access policy**: authenticated
 * @summary Deploy a new kubernetes stack from a url
 */
export const stackCreateKubernetesUrl = (
  stacksKubernetesManifestURLDeploymentPayload: StacksKubernetesManifestURLDeploymentPayload,
  params: StackCreateKubernetesUrlParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.post(
    `/stacks/create/kubernetes/url`,
    stacksKubernetesManifestURLDeploymentPayload,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getStackCreateKubernetesUrlMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateKubernetesUrl>>,
    TError,
    {
      data: StacksKubernetesManifestURLDeploymentPayload;
      params: StackCreateKubernetesUrlParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackCreateKubernetesUrl>>,
  TError,
  {
    data: StacksKubernetesManifestURLDeploymentPayload;
    params: StackCreateKubernetesUrlParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackCreateKubernetesUrl>>,
    {
      data: StacksKubernetesManifestURLDeploymentPayload;
      params: StackCreateKubernetesUrlParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return stackCreateKubernetesUrl(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackCreateKubernetesUrlMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackCreateKubernetesUrl>>
>;
export type StackCreateKubernetesUrlMutationBody =
  StacksKubernetesManifestURLDeploymentPayload;
export type StackCreateKubernetesUrlMutationError = AxiosError<void>;

export const useStackCreateKubernetesUrl = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateKubernetesUrl>>,
    TError,
    {
      data: StacksKubernetesManifestURLDeploymentPayload;
      params: StackCreateKubernetesUrlParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackCreateKubernetesUrlMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Deploy a new stack into a Docker environment specified via the environment identifier.
 **Access policy**: authenticated
 * @summary Deploy a new compose stack from a file
 */
export const stackCreateDockerStandaloneFile = (
  stackCreateDockerStandaloneFileBody: StackCreateDockerStandaloneFileBody,
  params: StackCreateDockerStandaloneFileParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> => {
  const formData = new FormData();
  formData.append('Name', stackCreateDockerStandaloneFileBody.Name);
  if (stackCreateDockerStandaloneFileBody.Env !== undefined) {
    formData.append('Env', stackCreateDockerStandaloneFileBody.Env);
  }
  if (stackCreateDockerStandaloneFileBody.file !== undefined) {
    formData.append('file', stackCreateDockerStandaloneFileBody.file);
  }

  return axios.post(`/stacks/create/standalone/file`, formData, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getStackCreateDockerStandaloneFileMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerStandaloneFile>>,
    TError,
    {
      data: StackCreateDockerStandaloneFileBody;
      params: StackCreateDockerStandaloneFileParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackCreateDockerStandaloneFile>>,
  TError,
  {
    data: StackCreateDockerStandaloneFileBody;
    params: StackCreateDockerStandaloneFileParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackCreateDockerStandaloneFile>>,
    {
      data: StackCreateDockerStandaloneFileBody;
      params: StackCreateDockerStandaloneFileParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return stackCreateDockerStandaloneFile(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackCreateDockerStandaloneFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackCreateDockerStandaloneFile>>
>;
export type StackCreateDockerStandaloneFileMutationBody =
  StackCreateDockerStandaloneFileBody;
export type StackCreateDockerStandaloneFileMutationError = AxiosError<void>;

export const useStackCreateDockerStandaloneFile = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerStandaloneFile>>,
    TError,
    {
      data: StackCreateDockerStandaloneFileBody;
      params: StackCreateDockerStandaloneFileParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions =
    getStackCreateDockerStandaloneFileMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Deploy a new stack into a Docker environment specified via the environment identifier.
 **Access policy**: authenticated
 * @summary Deploy a new compose stack from repository
 */
export const stackCreateDockerStandaloneRepository = (
  stacksComposeStackFromGitRepositoryPayload: StacksComposeStackFromGitRepositoryPayload,
  params: StackCreateDockerStandaloneRepositoryParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.post(
    `/stacks/create/standalone/repository`,
    stacksComposeStackFromGitRepositoryPayload,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getStackCreateDockerStandaloneRepositoryMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerStandaloneRepository>>,
    TError,
    {
      data: StacksComposeStackFromGitRepositoryPayload;
      params: StackCreateDockerStandaloneRepositoryParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackCreateDockerStandaloneRepository>>,
  TError,
  {
    data: StacksComposeStackFromGitRepositoryPayload;
    params: StackCreateDockerStandaloneRepositoryParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackCreateDockerStandaloneRepository>>,
    {
      data: StacksComposeStackFromGitRepositoryPayload;
      params: StackCreateDockerStandaloneRepositoryParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return stackCreateDockerStandaloneRepository(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackCreateDockerStandaloneRepositoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackCreateDockerStandaloneRepository>>
>;
export type StackCreateDockerStandaloneRepositoryMutationBody =
  StacksComposeStackFromGitRepositoryPayload;
export type StackCreateDockerStandaloneRepositoryMutationError =
  AxiosError<void>;

export const useStackCreateDockerStandaloneRepository = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerStandaloneRepository>>,
    TError,
    {
      data: StacksComposeStackFromGitRepositoryPayload;
      params: StackCreateDockerStandaloneRepositoryParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions =
    getStackCreateDockerStandaloneRepositoryMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Deploy a new stack into a Docker environment specified via the environment identifier.
 **Access policy**: authenticated
 * @summary Deploy a new compose stack from a text
 */
export const stackCreateDockerStandaloneString = (
  stacksComposeStackFromFileContentPayload: StacksComposeStackFromFileContentPayload,
  params: StackCreateDockerStandaloneStringParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.post(
    `/stacks/create/standalone/string`,
    stacksComposeStackFromFileContentPayload,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getStackCreateDockerStandaloneStringMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerStandaloneString>>,
    TError,
    {
      data: StacksComposeStackFromFileContentPayload;
      params: StackCreateDockerStandaloneStringParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackCreateDockerStandaloneString>>,
  TError,
  {
    data: StacksComposeStackFromFileContentPayload;
    params: StackCreateDockerStandaloneStringParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackCreateDockerStandaloneString>>,
    {
      data: StacksComposeStackFromFileContentPayload;
      params: StackCreateDockerStandaloneStringParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return stackCreateDockerStandaloneString(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackCreateDockerStandaloneStringMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackCreateDockerStandaloneString>>
>;
export type StackCreateDockerStandaloneStringMutationBody =
  StacksComposeStackFromFileContentPayload;
export type StackCreateDockerStandaloneStringMutationError = AxiosError<void>;

export const useStackCreateDockerStandaloneString = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerStandaloneString>>,
    TError,
    {
      data: StacksComposeStackFromFileContentPayload;
      params: StackCreateDockerStandaloneStringParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions =
    getStackCreateDockerStandaloneStringMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Deploy a new stack into a Docker environment specified via the environment identifier.
 **Access policy**: authenticated
 * @summary Deploy a new swarm stack from a file
 */
export const stackCreateDockerSwarmFile = (
  stackCreateDockerSwarmFileBody: StackCreateDockerSwarmFileBody,
  params: StackCreateDockerSwarmFileParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> => {
  const formData = new FormData();
  if (stackCreateDockerSwarmFileBody.Name !== undefined) {
    formData.append('Name', stackCreateDockerSwarmFileBody.Name);
  }
  if (stackCreateDockerSwarmFileBody.SwarmID !== undefined) {
    formData.append('SwarmID', stackCreateDockerSwarmFileBody.SwarmID);
  }
  if (stackCreateDockerSwarmFileBody.Env !== undefined) {
    formData.append('Env', stackCreateDockerSwarmFileBody.Env);
  }
  if (stackCreateDockerSwarmFileBody.file !== undefined) {
    formData.append('file', stackCreateDockerSwarmFileBody.file);
  }

  return axios.post(`/stacks/create/swarm/file`, formData, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getStackCreateDockerSwarmFileMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerSwarmFile>>,
    TError,
    {
      data: StackCreateDockerSwarmFileBody;
      params: StackCreateDockerSwarmFileParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackCreateDockerSwarmFile>>,
  TError,
  {
    data: StackCreateDockerSwarmFileBody;
    params: StackCreateDockerSwarmFileParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackCreateDockerSwarmFile>>,
    {
      data: StackCreateDockerSwarmFileBody;
      params: StackCreateDockerSwarmFileParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return stackCreateDockerSwarmFile(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackCreateDockerSwarmFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackCreateDockerSwarmFile>>
>;
export type StackCreateDockerSwarmFileMutationBody =
  StackCreateDockerSwarmFileBody;
export type StackCreateDockerSwarmFileMutationError = AxiosError<void>;

export const useStackCreateDockerSwarmFile = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerSwarmFile>>,
    TError,
    {
      data: StackCreateDockerSwarmFileBody;
      params: StackCreateDockerSwarmFileParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getStackCreateDockerSwarmFileMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Deploy a new stack into a Docker environment specified via the environment identifier.
 **Access policy**: authenticated
 * @summary Deploy a new swarm stack from a git repository
 */
export const stackCreateDockerSwarmRepository = (
  stacksSwarmStackFromGitRepositoryPayload: StacksSwarmStackFromGitRepositoryPayload,
  params: StackCreateDockerSwarmRepositoryParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.post(
    `/stacks/create/swarm/repository`,
    stacksSwarmStackFromGitRepositoryPayload,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getStackCreateDockerSwarmRepositoryMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerSwarmRepository>>,
    TError,
    {
      data: StacksSwarmStackFromGitRepositoryPayload;
      params: StackCreateDockerSwarmRepositoryParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackCreateDockerSwarmRepository>>,
  TError,
  {
    data: StacksSwarmStackFromGitRepositoryPayload;
    params: StackCreateDockerSwarmRepositoryParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackCreateDockerSwarmRepository>>,
    {
      data: StacksSwarmStackFromGitRepositoryPayload;
      params: StackCreateDockerSwarmRepositoryParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return stackCreateDockerSwarmRepository(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackCreateDockerSwarmRepositoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackCreateDockerSwarmRepository>>
>;
export type StackCreateDockerSwarmRepositoryMutationBody =
  StacksSwarmStackFromGitRepositoryPayload;
export type StackCreateDockerSwarmRepositoryMutationError = AxiosError<void>;

export const useStackCreateDockerSwarmRepository = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerSwarmRepository>>,
    TError,
    {
      data: StacksSwarmStackFromGitRepositoryPayload;
      params: StackCreateDockerSwarmRepositoryParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions =
    getStackCreateDockerSwarmRepositoryMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Deploy a new stack into a Docker environment specified via the environment identifier.
 **Access policy**: authenticated
 * @summary Deploy a new swarm stack from a text
 */
export const stackCreateDockerSwarmString = (
  stacksSwarmStackFromFileContentPayload: StacksSwarmStackFromFileContentPayload,
  params: StackCreateDockerSwarmStringParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeStack>> =>
  axios.post(
    `/stacks/create/swarm/string`,
    stacksSwarmStackFromFileContentPayload,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getStackCreateDockerSwarmStringMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerSwarmString>>,
    TError,
    {
      data: StacksSwarmStackFromFileContentPayload;
      params: StackCreateDockerSwarmStringParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof stackCreateDockerSwarmString>>,
  TError,
  {
    data: StacksSwarmStackFromFileContentPayload;
    params: StackCreateDockerSwarmStringParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof stackCreateDockerSwarmString>>,
    {
      data: StacksSwarmStackFromFileContentPayload;
      params: StackCreateDockerSwarmStringParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return stackCreateDockerSwarmString(data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StackCreateDockerSwarmStringMutationResult = NonNullable<
  Awaited<ReturnType<typeof stackCreateDockerSwarmString>>
>;
export type StackCreateDockerSwarmStringMutationBody =
  StacksSwarmStackFromFileContentPayload;
export type StackCreateDockerSwarmStringMutationError = AxiosError<void>;

export const useStackCreateDockerSwarmString = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof stackCreateDockerSwarmString>>,
    TError,
    {
      data: StacksSwarmStackFromFileContentPayload;
      params: StackCreateDockerSwarmStringParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions =
    getStackCreateDockerSwarmStringMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * **Access policy**: public
 * @summary Webhook for triggering stack updates from git
 */
export const webhookInvoke = (
  webhookID: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/stacks/webhooks/${webhookID}`, undefined, options);

export const getWebhookInvokeMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhookInvoke>>,
    TError,
    { webhookID: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof webhookInvoke>>,
  TError,
  { webhookID: string },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof webhookInvoke>>,
    { webhookID: string }
  > = (props) => {
    const { webhookID } = props ?? {};

    return webhookInvoke(webhookID, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type WebhookInvokeMutationResult = NonNullable<
  Awaited<ReturnType<typeof webhookInvoke>>
>;

export type WebhookInvokeMutationError = AxiosError<unknown>;

export const useWebhookInvoke = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof webhookInvoke>>,
    TError,
    { webhookID: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getWebhookInvokeMutationOptions(options);

  return useMutation(mutationOptions);
};
