/**
 * Generated by orval v6.15.0 üç∫
 * Do not edit manually.
 * PortainerEE API
 * Portainer API is an HTTP API served by Portainer. It is used by the Portainer UI and everything you can do with the UI can be done using the HTTP API.
Examples are available at https://documentation.portainer.io/api/api-examples/
You can find out more about Portainer at [http://portainer.io](http://portainer.io) and get some support on [Slack](http://portainer.io/slack/).

# Authentication

Most of the API environments(endpoints) require to be authenticated as well as some level of authorization to be used.
Portainer API uses JSON Web Token to manage authentication and thus requires you to provide a token in the **Authorization** header of each request
with the **Bearer** authentication mechanism.

Example:

```
Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsInJvbGUiOjEsImV4cCI6MTQ5OTM3NjE1NH0.NJ6vE8FY1WG6jsRQzfMqeatJ4vh2TWAeeYfDhP71YEE
```

# Security

Each API environment(endpoint) has an associated access policy, it is documented in the description of each environment(endpoint).

Different access policies are available:

- Public access
- Authenticated access
- Restricted access
- Administrator access

### Public access

No authentication is required to access the environments(endpoints) with this access policy.

### Authenticated access

Authentication is required to access the environments(endpoints) with this access policy.

### Restricted access

Authentication is required to access the environments(endpoints) with this access policy.
Extra-checks might be added to ensure access to the resource is granted. Returned data might also be filtered.

### Administrator access

Authentication as well as an administrator role are required to access the environments(endpoints) with this access policy.

# Execute Docker requests

Portainer **DO NOT** expose specific environments(endpoints) to manage your Docker resources (create a container, remove a volume, etc...).

Instead, it acts as a reverse-proxy to the Docker HTTP API. This means that you can execute Docker requests **via** the Portainer HTTP API.

To do so, you can use the `/endpoints/{id}/docker` Portainer API environment(endpoint) (which is not documented below due to Swagger limitations). This environment(endpoint) has a restricted access policy so you still need to be authenticated to be able to query this environment(endpoint). Any query on this environment(endpoint) will be proxied to the Docker API of the associated environment(endpoint) (requests and responses objects are the same as documented in the Docker API).

# Private Registry

Using private registry, you will need to pass a based64 encoded JSON string ‚Äò{"registryId":\<registryID value\>}‚Äô inside the Request Header. The parameter name is "X-Registry-Auth".
\<registryID value\> - The registry ID where the repository was created.

Example:

```
eyJyZWdpc3RyeUlkIjoxfQ==
```

**NOTE**: You can find more information on how to query the Docker API in the [Docker official documentation](https://docs.docker.com/engine/api/v1.30/) as well as in [this Portainer example](https://documentation.portainer.io/api/api-examples/).

 * OpenAPI spec version: 2.19.0
 */
import axios from 'axios';
import type { AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { useQuery, useMutation } from 'react-query';
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from 'react-query';

import type {
  PortainereeUser,
  UserListParams,
  UsersUserCreatePayload,
  UsersUserUpdatePayload,
  PortainereeGitCredential,
  UsersGitCredentialResponse,
  UsersUserGitCredentialCreatePayload,
  PortainereeTeamMembership,
  UsersNamespaceMapping,
  UsersUserUpdateOpenAIConfigPayload,
  UsersUserUpdatePasswordPayload,
  PortainereeAPIKey,
  UsersAccessTokenResponse,
  UsersUserAccessTokenCreatePayload,
  UsersAdminInitPayload,
} from '../portainerEEAPI.schemas';

/**
 * List Portainer users.
Non-administrator users will only be able to list other non-administrator user accounts.
User passwords are filtered out, and should never be accessible.
**Access policy**: restricted
 * @summary List users
 */
export const userList = (
  params?: UserListParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeUser[]>> =>
  axios.get(`/users`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getUserListQueryKey = (params?: UserListParams) =>
  [`/users`, ...(params ? [params] : [])] as const;

export const getUserListQueryOptions = <
  TData = Awaited<ReturnType<typeof userList>>,
  TError = AxiosError<void>
>(
  params?: UserListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserListQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userList>>> = ({
    signal,
  }) => userList(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions };
};

export type UserListQueryResult = NonNullable<
  Awaited<ReturnType<typeof userList>>
>;
export type UserListQueryError = AxiosError<void>;

export const useUserList = <
  TData = Awaited<ReturnType<typeof userList>>,
  TError = AxiosError<void>
>(
  params?: UserListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserListQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new Portainer user.
Only administrators can create users.
**Access policy**: restricted
 * @summary Create a new user
 */
export const userCreate = (
  usersUserCreatePayload: UsersUserCreatePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeUser>> =>
  axios.post(`/users`, usersUserCreatePayload, options);

export const getUserCreateMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userCreate>>,
    TError,
    { data: UsersUserCreatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userCreate>>,
  TError,
  { data: UsersUserCreatePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userCreate>>,
    { data: UsersUserCreatePayload }
  > = (props) => {
    const { data } = props ?? {};

    return userCreate(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof userCreate>>
>;
export type UserCreateMutationBody = UsersUserCreatePayload;
export type UserCreateMutationError = AxiosError<void>;

export const useUserCreate = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userCreate>>,
    TError,
    { data: UsersUserCreatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUserCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Remove a user.
 **Access policy**: administrator
 * @summary Remove a user
 */
export const userDelete = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => axios.delete(`/users/${id}`, options);

export const getUserDeleteMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userDelete>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userDelete>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userDelete>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return userDelete(id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof userDelete>>
>;

export type UserDeleteMutationError = AxiosError<unknown>;

export const useUserDelete = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userDelete>>,
    TError,
    { id: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUserDeleteMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Retrieve details about a user.
User passwords are filtered out, and should never be accessible.
**Access policy**: authenticated
 * @summary Inspect a user
 */
export const userInspect = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeUser>> =>
  axios.get(`/users/${id}`, options);

export const getUserInspectQueryKey = (id: number) => [`/users/${id}`] as const;

export const getUserInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof userInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof userInspect>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserInspectQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userInspect>>> = ({
    signal,
  }) => userInspect(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type UserInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof userInspect>>
>;
export type UserInspectQueryError = AxiosError<void>;

export const useUserInspect = <
  TData = Awaited<ReturnType<typeof userInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserInspectQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update user details. A regular user account can only update his details.
 **Access policy**: authenticated
 * @summary Update a user
 */
export const userUpdate = (
  id: number,
  usersUserUpdatePayload: UsersUserUpdatePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeUser>> =>
  axios.put(`/users/${id}`, usersUserUpdatePayload, options);

export const getUserUpdateMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userUpdate>>,
    TError,
    { id: number; data: UsersUserUpdatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userUpdate>>,
  TError,
  { id: number; data: UsersUserUpdatePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userUpdate>>,
    { id: number; data: UsersUserUpdatePayload }
  > = (props) => {
    const { id, data } = props ?? {};

    return userUpdate(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof userUpdate>>
>;
export type UserUpdateMutationBody = UsersUserUpdatePayload;
export type UserUpdateMutationError = AxiosError<void>;

export const useUserUpdate = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userUpdate>>,
    TError,
    { id: number; data: UsersUserUpdatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUserUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Gets all saved git credentials for a user.
Only the calling user can retrieve git credentials
**Access policy**: authenticated
 * @summary Get all saved git credentials for a user
 */
export const userGetGitCredentials = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeGitCredential[]>> =>
  axios.get(`/users/${id}/gitcredentials`, options);

export const getUserGetGitCredentialsQueryKey = (id: number) =>
  [`/users/${id}/gitcredentials`] as const;

export const getUserGetGitCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof userGetGitCredentials>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userGetGitCredentials>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof userGetGitCredentials>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserGetGitCredentialsQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userGetGitCredentials>>
  > = ({ signal }) => userGetGitCredentials(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type UserGetGitCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof userGetGitCredentials>>
>;
export type UserGetGitCredentialsQueryError = AxiosError<void>;

export const useUserGetGitCredentials = <
  TData = Awaited<ReturnType<typeof userGetGitCredentials>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userGetGitCredentials>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserGetGitCredentialsQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Store a Git Credential for a user.
Only the calling user can store a git credential for themselves.
**Access policy**: restricted
 * @summary Store a Git Credential for a user
 */
export const userCreateGitCredential = (
  id: number,
  usersUserGitCredentialCreatePayload: UsersUserGitCredentialCreatePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<UsersGitCredentialResponse>> =>
  axios.post(
    `/users/${id}/gitcredentials`,
    usersUserGitCredentialCreatePayload,
    options
  );

export const getUserCreateGitCredentialMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userCreateGitCredential>>,
    TError,
    { id: number; data: UsersUserGitCredentialCreatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userCreateGitCredential>>,
  TError,
  { id: number; data: UsersUserGitCredentialCreatePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userCreateGitCredential>>,
    { id: number; data: UsersUserGitCredentialCreatePayload }
  > = (props) => {
    const { id, data } = props ?? {};

    return userCreateGitCredential(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserCreateGitCredentialMutationResult = NonNullable<
  Awaited<ReturnType<typeof userCreateGitCredential>>
>;
export type UserCreateGitCredentialMutationBody =
  UsersUserGitCredentialCreatePayload;
export type UserCreateGitCredentialMutationError = AxiosError<void>;

export const useUserCreateGitCredential = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userCreateGitCredential>>,
    TError,
    { id: number; data: UsersUserGitCredentialCreatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUserCreateGitCredentialMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Remove a git-credential associated to a user..
Only the calling user can remove git-credential
**Access policy**: authenticated
 * @summary Remove a git-credential associated to a user
 */
export const userRemoveGitCredential = (
  id: number,
  credentialID: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.delete(`/users/${id}/gitcredentials/${credentialID}`, options);

export const getUserRemoveGitCredentialMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userRemoveGitCredential>>,
    TError,
    { id: number; credentialID: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userRemoveGitCredential>>,
  TError,
  { id: number; credentialID: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userRemoveGitCredential>>,
    { id: number; credentialID: number }
  > = (props) => {
    const { id, credentialID } = props ?? {};

    return userRemoveGitCredential(id, credentialID, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserRemoveGitCredentialMutationResult = NonNullable<
  Awaited<ReturnType<typeof userRemoveGitCredential>>
>;

export type UserRemoveGitCredentialMutationError = AxiosError<unknown>;

export const useUserRemoveGitCredential = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userRemoveGitCredential>>,
    TError,
    { id: number; credentialID: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUserRemoveGitCredentialMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Gets the specific saved git credential for a user.
Only the calling user can retrieve git credential
**Access policy**: authenticated
 * @summary Get the specific saved git credential for a user
 */
export const userGetGitCredential = (
  id: number,
  credentialID: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeGitCredential>> =>
  axios.get(`/users/${id}/gitcredentials/${credentialID}`, options);

export const getUserGetGitCredentialQueryKey = (
  id: number,
  credentialID: number
) => [`/users/${id}/gitcredentials/${credentialID}`] as const;

export const getUserGetGitCredentialQueryOptions = <
  TData = Awaited<ReturnType<typeof userGetGitCredential>>,
  TError = AxiosError<void>
>(
  id: number,
  credentialID: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userGetGitCredential>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof userGetGitCredential>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserGetGitCredentialQueryKey(id, credentialID);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userGetGitCredential>>
  > = ({ signal }) =>
    userGetGitCredential(id, credentialID, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!(id && credentialID),
    ...queryOptions,
  };
};

export type UserGetGitCredentialQueryResult = NonNullable<
  Awaited<ReturnType<typeof userGetGitCredential>>
>;
export type UserGetGitCredentialQueryError = AxiosError<void>;

export const useUserGetGitCredential = <
  TData = Awaited<ReturnType<typeof userGetGitCredential>>,
  TError = AxiosError<void>
>(
  id: number,
  credentialID: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userGetGitCredential>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserGetGitCredentialQueryOptions(
    id,
    credentialID,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update a git-credential associated to a user..
Only the calling user can update git-credential
**Access policy**: authenticated
 * @summary Update a git-credential associated to a user
 */
export const userUpdateGitCredential = (
  id: number,
  credentialID: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.put(`/users/${id}/gitcredentials/${credentialID}`, undefined, options);

export const getUserUpdateGitCredentialMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userUpdateGitCredential>>,
    TError,
    { id: number; credentialID: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userUpdateGitCredential>>,
  TError,
  { id: number; credentialID: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userUpdateGitCredential>>,
    { id: number; credentialID: number }
  > = (props) => {
    const { id, credentialID } = props ?? {};

    return userUpdateGitCredential(id, credentialID, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserUpdateGitCredentialMutationResult = NonNullable<
  Awaited<ReturnType<typeof userUpdateGitCredential>>
>;

export type UserUpdateGitCredentialMutationError = AxiosError<unknown>;

export const useUserUpdateGitCredential = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userUpdateGitCredential>>,
    TError,
    { id: number; credentialID: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUserUpdateGitCredentialMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Inspect a user memberships.
 **Access policy**: restricted
 * @summary Inspect a user memberships
 */
export const userMembershipsInspect = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeTeamMembership>> =>
  axios.get(`/users/${id}/memberships`, options);

export const getUserMembershipsInspectQueryKey = (id: number) =>
  [`/users/${id}/memberships`] as const;

export const getUserMembershipsInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof userMembershipsInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userMembershipsInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof userMembershipsInspect>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserMembershipsInspectQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userMembershipsInspect>>
  > = ({ signal }) => userMembershipsInspect(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type UserMembershipsInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof userMembershipsInspect>>
>;
export type UserMembershipsInspectQueryError = AxiosError<void>;

export const useUserMembershipsInspect = <
  TData = Awaited<ReturnType<typeof userMembershipsInspect>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userMembershipsInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserMembershipsInspectQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Retrieves user's role authorizations of all namespaces in all k8s environments(endpoints)
 **Access policy**: restricted
 * @summary Retrieves all k8s namespaces for an user
 */
export const userNamespaces = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<UsersNamespaceMapping>> =>
  axios.get(`/users/${id}/namespaces`, options);

export const getUserNamespacesQueryKey = (id: number) =>
  [`/users/${id}/namespaces`] as const;

export const getUserNamespacesQueryOptions = <
  TData = Awaited<ReturnType<typeof userNamespaces>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userNamespaces>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof userNamespaces>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserNamespacesQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userNamespaces>>> = ({
    signal,
  }) => userNamespaces(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type UserNamespacesQueryResult = NonNullable<
  Awaited<ReturnType<typeof userNamespaces>>
>;
export type UserNamespacesQueryError = AxiosError<void>;

export const useUserNamespaces = <
  TData = Awaited<ReturnType<typeof userNamespaces>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userNamespaces>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserNamespacesQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update the OpenAI API key and OpenAI model associated to a user. Requires the OpenAI experimental feature setting to be enabled.
This configuration will be used when interacting with the OpenAI chat.
Only an administrator user or the user itself can update the OpenAI API key.
**Access policy**: restricted
 * @summary Update the OpenAI API configuration associated to a user.
 */
export const userUpdateOpenAIConfig = (
  id: number,
  usersUserUpdateOpenAIConfigPayload: UsersUserUpdateOpenAIConfigPayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.put(`/users/${id}/openai`, usersUserUpdateOpenAIConfigPayload, options);

export const getUserUpdateOpenAIConfigMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userUpdateOpenAIConfig>>,
    TError,
    { id: number; data: UsersUserUpdateOpenAIConfigPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userUpdateOpenAIConfig>>,
  TError,
  { id: number; data: UsersUserUpdateOpenAIConfigPayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userUpdateOpenAIConfig>>,
    { id: number; data: UsersUserUpdateOpenAIConfigPayload }
  > = (props) => {
    const { id, data } = props ?? {};

    return userUpdateOpenAIConfig(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserUpdateOpenAIConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof userUpdateOpenAIConfig>>
>;
export type UserUpdateOpenAIConfigMutationBody =
  UsersUserUpdateOpenAIConfigPayload;
export type UserUpdateOpenAIConfigMutationError = AxiosError<unknown>;

export const useUserUpdateOpenAIConfig = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userUpdateOpenAIConfig>>,
    TError,
    { id: number; data: UsersUserUpdateOpenAIConfigPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUserUpdateOpenAIConfigMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Update password for the specified user.
 **Access policy**: authenticated
 * @summary Update password for a user
 */
export const userUpdatePassword = (
  id: number,
  usersUserUpdatePasswordPayload: UsersUserUpdatePasswordPayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.put(`/users/${id}/passwd`, usersUserUpdatePasswordPayload, options);

export const getUserUpdatePasswordMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userUpdatePassword>>,
    TError,
    { id: number; data: UsersUserUpdatePasswordPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userUpdatePassword>>,
  TError,
  { id: number; data: UsersUserUpdatePasswordPayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userUpdatePassword>>,
    { id: number; data: UsersUserUpdatePasswordPayload }
  > = (props) => {
    const { id, data } = props ?? {};

    return userUpdatePassword(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserUpdatePasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof userUpdatePassword>>
>;
export type UserUpdatePasswordMutationBody = UsersUserUpdatePasswordPayload;
export type UserUpdatePasswordMutationError = AxiosError<unknown>;

export const useUserUpdatePassword = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userUpdatePassword>>,
    TError,
    { id: number; data: UsersUserUpdatePasswordPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUserUpdatePasswordMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Gets all API keys for a user.
Only the calling user or admin can retrieve api-keys.
**Access policy**: authenticated
 * @summary Get all API keys for a user
 */
export const userGetAPIKeys = (
  id: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeAPIKey[]>> =>
  axios.get(`/users/${id}/tokens`, options);

export const getUserGetAPIKeysQueryKey = (id: number) =>
  [`/users/${id}/tokens`] as const;

export const getUserGetAPIKeysQueryOptions = <
  TData = Awaited<ReturnType<typeof userGetAPIKeys>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userGetAPIKeys>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof userGetAPIKeys>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserGetAPIKeysQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userGetAPIKeys>>> = ({
    signal,
  }) => userGetAPIKeys(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions };
};

export type UserGetAPIKeysQueryResult = NonNullable<
  Awaited<ReturnType<typeof userGetAPIKeys>>
>;
export type UserGetAPIKeysQueryError = AxiosError<void>;

export const useUserGetAPIKeys = <
  TData = Awaited<ReturnType<typeof userGetAPIKeys>>,
  TError = AxiosError<void>
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof userGetAPIKeys>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserGetAPIKeysQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Generates an API key for a user.
Only the calling user can generate a token for themselves.
**Access policy**: restricted
 * @summary Generate an API key for a user
 */
export const userGenerateAPIKey = (
  id: number,
  usersUserAccessTokenCreatePayload: UsersUserAccessTokenCreatePayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<UsersAccessTokenResponse>> =>
  axios.post(`/users/${id}/tokens`, usersUserAccessTokenCreatePayload, options);

export const getUserGenerateAPIKeyMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userGenerateAPIKey>>,
    TError,
    { id: number; data: UsersUserAccessTokenCreatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userGenerateAPIKey>>,
  TError,
  { id: number; data: UsersUserAccessTokenCreatePayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userGenerateAPIKey>>,
    { id: number; data: UsersUserAccessTokenCreatePayload }
  > = (props) => {
    const { id, data } = props ?? {};

    return userGenerateAPIKey(id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserGenerateAPIKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof userGenerateAPIKey>>
>;
export type UserGenerateAPIKeyMutationBody = UsersUserAccessTokenCreatePayload;
export type UserGenerateAPIKeyMutationError = AxiosError<void>;

export const useUserGenerateAPIKey = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userGenerateAPIKey>>,
    TError,
    { id: number; data: UsersUserAccessTokenCreatePayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUserGenerateAPIKeyMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Remove an api-key associated to a user..
Only the calling user or admin can remove api-key.
**Access policy**: authenticated
 * @summary Remove an api-key associated to a user
 */
export const userRemoveAPIKey = (
  id: number,
  keyID: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.delete(`/users/${id}/tokens/${keyID}`, options);

export const getUserRemoveAPIKeyMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userRemoveAPIKey>>,
    TError,
    { id: number; keyID: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userRemoveAPIKey>>,
  TError,
  { id: number; keyID: number },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userRemoveAPIKey>>,
    { id: number; keyID: number }
  > = (props) => {
    const { id, keyID } = props ?? {};

    return userRemoveAPIKey(id, keyID, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserRemoveAPIKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof userRemoveAPIKey>>
>;

export type UserRemoveAPIKeyMutationError = AxiosError<unknown>;

export const useUserRemoveAPIKey = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userRemoveAPIKey>>,
    TError,
    { id: number; keyID: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUserRemoveAPIKeyMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Check if an administrator account exists in the database.
 **Access policy**: public
 * @summary Check administrator account existence
 */
export const userAdminCheck = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => axios.get(`/users/admin/check`, options);

export const getUserAdminCheckQueryKey = () => [`/users/admin/check`] as const;

export const getUserAdminCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof userAdminCheck>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof userAdminCheck>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryOptions<
  Awaited<ReturnType<typeof userAdminCheck>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserAdminCheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userAdminCheck>>> = ({
    signal,
  }) => userAdminCheck({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions };
};

export type UserAdminCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof userAdminCheck>>
>;
export type UserAdminCheckQueryError = AxiosError<unknown>;

export const useUserAdminCheck = <
  TData = Awaited<ReturnType<typeof userAdminCheck>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof userAdminCheck>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getUserAdminCheckQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Initialize the 'admin' user account.
 **Access policy**: public
 * @summary Initialize administrator account
 */
export const userAdminInit = (
  usersAdminInitPayload: UsersAdminInitPayload,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<PortainereeUser>> =>
  axios.post(`/users/admin/init`, usersAdminInitPayload, options);

export const getUserAdminInitMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userAdminInit>>,
    TError,
    { data: UsersAdminInitPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userAdminInit>>,
  TError,
  { data: UsersAdminInitPayload },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userAdminInit>>,
    { data: UsersAdminInitPayload }
  > = (props) => {
    const { data } = props ?? {};

    return userAdminInit(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserAdminInitMutationResult = NonNullable<
  Awaited<ReturnType<typeof userAdminInit>>
>;
export type UserAdminInitMutationBody = UsersAdminInitPayload;
export type UserAdminInitMutationError = AxiosError<void>;

export const useUserAdminInit = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userAdminInit>>,
    TError,
    { data: UsersAdminInitPayload },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUserAdminInitMutationOptions(options);

  return useMutation(mutationOptions);
};
