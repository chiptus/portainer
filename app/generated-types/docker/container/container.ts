/**
 * Generated by orval v6.15.0 üç∫
 * Do not edit manually.
 * Docker Engine API
 * The Engine API is an HTTP API served by Docker Engine. It is the API the
Docker client uses to communicate with the Engine, so everything the Docker
client can do can be done with the API.

Most of the client's commands map directly to API endpoints (e.g. `docker ps`
is `GET /containers/json`). The notable exception is running containers,
which consists of several API calls.

# Errors

The API uses standard HTTP status codes to indicate the success or failure
of the API call. The body of the response will be JSON in the following
format:

```
{
  "message": "page not found"
}
```

# Versioning

The API is usually changed in each release, so API calls are versioned to
ensure that clients don't break. To lock to a specific version of the API,
you prefix the URL with its version, for example, call `/v1.30/info` to use
the v1.30 version of the `/info` endpoint. If the API version specified in
the URL is not supported by the daemon, a HTTP `400 Bad Request` error message
is returned.

If you omit the version-prefix, the current version of the API (v1.41) is used.
For example, calling `/info` is the same as calling `/v1.41/info`. Using the
API without a version-prefix is deprecated and will be removed in a future release.

Engine releases in the near future should support this version of the API,
so your client will continue to work even if it is talking to a newer Engine.

The API uses an open schema model, which means server may add extra properties
to responses. Likewise, the server will ignore any extra query parameters and
request body properties. When you write clients, you need to ignore additional
properties in responses to ensure they do not break when talking to newer
daemons.


# Authentication

Authentication for registries is handled client side. The client has to send
authentication details to various endpoints that need to communicate with
registries, such as `POST /images/(name)/push`. These are sent as
`X-Registry-Auth` header as a [base64url encoded](https://tools.ietf.org/html/rfc4648#section-5)
(JSON) string with the following structure:

```
{
  "username": "string",
  "password": "string",
  "email": "string",
  "serveraddress": "string"
}
```

The `serveraddress` is a domain/IP without a protocol. Throughout this
structure, double quotes are required.

If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth),
you can just pass this instead of credentials:

```
{
  "identitytoken": "9cbaf023786cd7..."
}
```

 * OpenAPI spec version: 1.41
 */
import axios from 'axios';
import type { AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { useQuery, useMutation } from 'react-query';
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from 'react-query';

import type {
  ContainerSummary,
  ErrorResponse,
  ContainerListParams,
  ContainerCreate201,
  ContainerCreateBodyOne,
  ContainerCreateBodyTwo,
  ContainerCreateParams,
  ContainerInspect200,
  ContainerInspectParams,
  ContainerTop200One,
  ContainerTop200Two,
  ContainerTopParams,
  ContainerLogsParams,
  ContainerChanges200Item,
  ContainerStats200,
  ContainerStatsParams,
  ContainerResizeParams,
  ContainerStartParams,
  ContainerStopParams,
  ContainerRestartParams,
  ContainerKillParams,
  ContainerUpdate200,
  ContainerUpdateBody,
  ContainerRenameParams,
  ContainerAttachParams,
  ContainerAttachWebsocketParams,
  ContainerWaitResponse,
  ContainerWaitParams,
  ContainerDeleteParams,
  ContainerArchiveInfoParams,
  ContainerArchiveParams,
  PutContainerArchiveParams,
  ContainerPrune200,
  ContainerPruneParams,
} from '../dockerEngineAPI.schemas';

/**
 * Returns a list of containers. For details on the format, see the
[inspect endpoint](#operation/ContainerInspect).

Note that it uses a different, smaller representation of a container
than inspecting a single container. For example, the list of linked
containers is not propagated .

 * @summary List containers
 */
export const containerList = (
  endpointId: number,
  params?: ContainerListParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ContainerSummary[]>> =>
  axios.get(`/endpoints/${endpointId}/docker/containers/json`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getContainerListQueryKey = (
  endpointId: number,
  params?: ContainerListParams
) =>
  [
    `/endpoints/${endpointId}/docker/containers/json`,
    ...(params ? [params] : []),
  ] as const;

export const getContainerListQueryOptions = <
  TData = Awaited<ReturnType<typeof containerList>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  params?: ContainerListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof containerList>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getContainerListQueryKey(endpointId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof containerList>>> = ({
    signal,
  }) => containerList(endpointId, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!endpointId, ...queryOptions };
};

export type ContainerListQueryResult = NonNullable<
  Awaited<ReturnType<typeof containerList>>
>;
export type ContainerListQueryError = AxiosError<ErrorResponse>;

export const useContainerList = <
  TData = Awaited<ReturnType<typeof containerList>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  params?: ContainerListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContainerListQueryOptions(
    endpointId,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Create a container
 */
export const containerCreate = (
  endpointId: number,
  containerCreateBody: ContainerCreateBodyOne | ContainerCreateBodyTwo,
  params?: ContainerCreateParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ContainerCreate201>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/create`,
    containerCreateBody,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getContainerCreateMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerCreate>>,
    TError,
    {
      endpointId: number;
      data: ContainerCreateBodyOne | ContainerCreateBodyTwo;
      params?: ContainerCreateParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerCreate>>,
  TError,
  {
    endpointId: number;
    data: ContainerCreateBodyOne | ContainerCreateBodyTwo;
    params?: ContainerCreateParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerCreate>>,
    {
      endpointId: number;
      data: ContainerCreateBodyOne | ContainerCreateBodyTwo;
      params?: ContainerCreateParams;
    }
  > = (props) => {
    const { endpointId, data, params } = props ?? {};

    return containerCreate(endpointId, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerCreate>>
>;
export type ContainerCreateMutationBody =
  | ContainerCreateBodyOne
  | ContainerCreateBodyTwo;
export type ContainerCreateMutationError = AxiosError<ErrorResponse>;

export const useContainerCreate = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerCreate>>,
    TError,
    {
      endpointId: number;
      data: ContainerCreateBodyOne | ContainerCreateBodyTwo;
      params?: ContainerCreateParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Return low-level information about a container.
 * @summary Inspect a container
 */
export const containerInspect = (
  endpointId: number,
  id: string,
  params?: ContainerInspectParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ContainerInspect200>> =>
  axios.get(`/endpoints/${endpointId}/docker/containers/${id}/json`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getContainerInspectQueryKey = (
  endpointId: number,
  id: string,
  params?: ContainerInspectParams
) =>
  [
    `/endpoints/${endpointId}/docker/containers/${id}/json`,
    ...(params ? [params] : []),
  ] as const;

export const getContainerInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof containerInspect>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  params?: ContainerInspectParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof containerInspect>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getContainerInspectQueryKey(endpointId, id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof containerInspect>>
  > = ({ signal }) =>
    containerInspect(endpointId, id, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!(endpointId && id), ...queryOptions };
};

export type ContainerInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof containerInspect>>
>;
export type ContainerInspectQueryError = AxiosError<ErrorResponse>;

export const useContainerInspect = <
  TData = Awaited<ReturnType<typeof containerInspect>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  params?: ContainerInspectParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContainerInspectQueryOptions(
    endpointId,
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * On Unix systems, this is done by running the `ps` command. This endpoint
is not supported on Windows.

 * @summary List processes running inside a container
 */
export const containerTop = (
  endpointId: number,
  id: string,
  params?: ContainerTopParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ContainerTop200One | ContainerTop200Two>> =>
  axios.get(`/endpoints/${endpointId}/docker/containers/${id}/top`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getContainerTopQueryKey = (
  endpointId: number,
  id: string,
  params?: ContainerTopParams
) =>
  [
    `/endpoints/${endpointId}/docker/containers/${id}/top`,
    ...(params ? [params] : []),
  ] as const;

export const getContainerTopQueryOptions = <
  TData = Awaited<ReturnType<typeof containerTop>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  params?: ContainerTopParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerTop>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof containerTop>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getContainerTopQueryKey(endpointId, id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof containerTop>>> = ({
    signal,
  }) => containerTop(endpointId, id, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!(endpointId && id), ...queryOptions };
};

export type ContainerTopQueryResult = NonNullable<
  Awaited<ReturnType<typeof containerTop>>
>;
export type ContainerTopQueryError = AxiosError<ErrorResponse>;

export const useContainerTop = <
  TData = Awaited<ReturnType<typeof containerTop>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  params?: ContainerTopParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerTop>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContainerTopQueryOptions(
    endpointId,
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get `stdout` and `stderr` logs from a container.

Note: This endpoint works only for containers with the `json-file` or
`journald` logging driver.

 * @summary Get container logs
 */
export const containerLogs = (
  endpointId: number,
  id: string,
  params?: ContainerLogsParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Blob>> =>
  axios.get(`/endpoints/${endpointId}/docker/containers/${id}/logs`, {
    responseType: 'blob',
    ...options,
    params: { ...params, ...options?.params },
  });

export const getContainerLogsQueryKey = (
  endpointId: number,
  id: string,
  params?: ContainerLogsParams
) =>
  [
    `/endpoints/${endpointId}/docker/containers/${id}/logs`,
    ...(params ? [params] : []),
  ] as const;

export const getContainerLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof containerLogs>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  params?: ContainerLogsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerLogs>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof containerLogs>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getContainerLogsQueryKey(endpointId, id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof containerLogs>>> = ({
    signal,
  }) => containerLogs(endpointId, id, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!(endpointId && id), ...queryOptions };
};

export type ContainerLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof containerLogs>>
>;
export type ContainerLogsQueryError = AxiosError<ErrorResponse>;

export const useContainerLogs = <
  TData = Awaited<ReturnType<typeof containerLogs>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  params?: ContainerLogsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerLogs>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContainerLogsQueryOptions(
    endpointId,
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Returns which files in a container's filesystem have been added, deleted,
or modified. The `Kind` of modification can be one of:

- `0`: Modified
- `1`: Added
- `2`: Deleted

 * @summary Get changes on a container‚Äôs filesystem
 */
export const containerChanges = (
  endpointId: number,
  id: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ContainerChanges200Item[]>> =>
  axios.get(
    `/endpoints/${endpointId}/docker/containers/${id}/changes`,
    options
  );

export const getContainerChangesQueryKey = (endpointId: number, id: string) =>
  [`/endpoints/${endpointId}/docker/containers/${id}/changes`] as const;

export const getContainerChangesQueryOptions = <
  TData = Awaited<ReturnType<typeof containerChanges>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerChanges>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof containerChanges>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getContainerChangesQueryKey(endpointId, id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof containerChanges>>
  > = ({ signal }) =>
    containerChanges(endpointId, id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!(endpointId && id), ...queryOptions };
};

export type ContainerChangesQueryResult = NonNullable<
  Awaited<ReturnType<typeof containerChanges>>
>;
export type ContainerChangesQueryError = AxiosError<ErrorResponse>;

export const useContainerChanges = <
  TData = Awaited<ReturnType<typeof containerChanges>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerChanges>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContainerChangesQueryOptions(endpointId, id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Export the contents of a container as a tarball.
 * @summary Export a container
 */
export const containerExport = (
  endpointId: number,
  id: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.get(`/endpoints/${endpointId}/docker/containers/${id}/export`, options);

export const getContainerExportQueryKey = (endpointId: number, id: string) =>
  [`/endpoints/${endpointId}/docker/containers/${id}/export`] as const;

export const getContainerExportQueryOptions = <
  TData = Awaited<ReturnType<typeof containerExport>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerExport>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof containerExport>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getContainerExportQueryKey(endpointId, id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof containerExport>>> = ({
    signal,
  }) => containerExport(endpointId, id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!(endpointId && id), ...queryOptions };
};

export type ContainerExportQueryResult = NonNullable<
  Awaited<ReturnType<typeof containerExport>>
>;
export type ContainerExportQueryError = AxiosError<ErrorResponse>;

export const useContainerExport = <
  TData = Awaited<ReturnType<typeof containerExport>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerExport>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContainerExportQueryOptions(endpointId, id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * This endpoint returns a live stream of a container‚Äôs resource usage
statistics.

The `precpu_stats` is the CPU statistic of the *previous* read, and is
used to calculate the CPU usage percentage. It is not an exact copy
of the `cpu_stats` field.

If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is
nil then for compatibility with older daemons the length of the
corresponding `cpu_usage.percpu_usage` array should be used.

On a cgroup v2 host, the following fields are not set
* `blkio_stats`: all fields other than `io_service_bytes_recursive`
* `cpu_stats`: `cpu_usage.percpu_usage`
* `memory_stats`: `max_usage` and `failcnt`
Also, `memory_stats.stats` fields are incompatible with cgroup v1.

To calculate the values shown by the `stats` command of the docker cli tool
the following formulas can be used:
* used_memory = `memory_stats.usage - memory_stats.stats.cache`
* available_memory = `memory_stats.limit`
* Memory usage % = `(used_memory / available_memory) * 100.0`
* cpu_delta = `cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage`
* system_cpu_delta = `cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage`
* number_cpus = `lenght(cpu_stats.cpu_usage.percpu_usage)` or `cpu_stats.online_cpus`
* CPU usage % = `(cpu_delta / system_cpu_delta) * number_cpus * 100.0`

 * @summary Get container stats based on resource usage
 */
export const containerStats = (
  endpointId: number,
  id: string,
  params?: ContainerStatsParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ContainerStats200>> =>
  axios.get(`/endpoints/${endpointId}/docker/containers/${id}/stats`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getContainerStatsQueryKey = (
  endpointId: number,
  id: string,
  params?: ContainerStatsParams
) =>
  [
    `/endpoints/${endpointId}/docker/containers/${id}/stats`,
    ...(params ? [params] : []),
  ] as const;

export const getContainerStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof containerStats>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  params?: ContainerStatsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerStats>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof containerStats>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getContainerStatsQueryKey(endpointId, id, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof containerStats>>> = ({
    signal,
  }) => containerStats(endpointId, id, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!(endpointId && id), ...queryOptions };
};

export type ContainerStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof containerStats>>
>;
export type ContainerStatsQueryError = AxiosError<ErrorResponse>;

export const useContainerStats = <
  TData = Awaited<ReturnType<typeof containerStats>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  params?: ContainerStatsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerStats>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContainerStatsQueryOptions(
    endpointId,
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Resize the TTY for a container.
 * @summary Resize a container TTY
 */
export const containerResize = (
  endpointId: number,
  id: string,
  params?: ContainerResizeParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/${id}/resize`,
    undefined,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getContainerResizeMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerResize>>,
    TError,
    { endpointId: number; id: string; params?: ContainerResizeParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerResize>>,
  TError,
  { endpointId: number; id: string; params?: ContainerResizeParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerResize>>,
    { endpointId: number; id: string; params?: ContainerResizeParams }
  > = (props) => {
    const { endpointId, id, params } = props ?? {};

    return containerResize(endpointId, id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerResizeMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerResize>>
>;

export type ContainerResizeMutationError = AxiosError<ErrorResponse>;

export const useContainerResize = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerResize>>,
    TError,
    { endpointId: number; id: string; params?: ContainerResizeParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerResizeMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Start a container
 */
export const containerStart = (
  endpointId: number,
  id: string,
  params?: ContainerStartParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/${id}/start`,
    undefined,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getContainerStartMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerStart>>,
    TError,
    { endpointId: number; id: string; params?: ContainerStartParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerStart>>,
  TError,
  { endpointId: number; id: string; params?: ContainerStartParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerStart>>,
    { endpointId: number; id: string; params?: ContainerStartParams }
  > = (props) => {
    const { endpointId, id, params } = props ?? {};

    return containerStart(endpointId, id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerStartMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerStart>>
>;

export type ContainerStartMutationError = AxiosError<ErrorResponse>;

export const useContainerStart = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerStart>>,
    TError,
    { endpointId: number; id: string; params?: ContainerStartParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerStartMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Stop a container
 */
export const containerStop = (
  endpointId: number,
  id: string,
  params?: ContainerStopParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/${id}/stop`,
    undefined,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getContainerStopMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerStop>>,
    TError,
    { endpointId: number; id: string; params?: ContainerStopParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerStop>>,
  TError,
  { endpointId: number; id: string; params?: ContainerStopParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerStop>>,
    { endpointId: number; id: string; params?: ContainerStopParams }
  > = (props) => {
    const { endpointId, id, params } = props ?? {};

    return containerStop(endpointId, id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerStopMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerStop>>
>;

export type ContainerStopMutationError = AxiosError<ErrorResponse>;

export const useContainerStop = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerStop>>,
    TError,
    { endpointId: number; id: string; params?: ContainerStopParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerStopMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Restart a container
 */
export const containerRestart = (
  endpointId: number,
  id: string,
  params?: ContainerRestartParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/${id}/restart`,
    undefined,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getContainerRestartMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerRestart>>,
    TError,
    { endpointId: number; id: string; params?: ContainerRestartParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerRestart>>,
  TError,
  { endpointId: number; id: string; params?: ContainerRestartParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerRestart>>,
    { endpointId: number; id: string; params?: ContainerRestartParams }
  > = (props) => {
    const { endpointId, id, params } = props ?? {};

    return containerRestart(endpointId, id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerRestartMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerRestart>>
>;

export type ContainerRestartMutationError = AxiosError<ErrorResponse>;

export const useContainerRestart = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerRestart>>,
    TError,
    { endpointId: number; id: string; params?: ContainerRestartParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerRestartMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Send a POSIX signal to a container, defaulting to killing to the
container.

 * @summary Kill a container
 */
export const containerKill = (
  endpointId: number,
  id: string,
  params?: ContainerKillParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/${id}/kill`,
    undefined,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getContainerKillMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerKill>>,
    TError,
    { endpointId: number; id: string; params?: ContainerKillParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerKill>>,
  TError,
  { endpointId: number; id: string; params?: ContainerKillParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerKill>>,
    { endpointId: number; id: string; params?: ContainerKillParams }
  > = (props) => {
    const { endpointId, id, params } = props ?? {};

    return containerKill(endpointId, id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerKillMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerKill>>
>;

export type ContainerKillMutationError = AxiosError<ErrorResponse>;

export const useContainerKill = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerKill>>,
    TError,
    { endpointId: number; id: string; params?: ContainerKillParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerKillMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Change various configuration options of a container without having to
recreate it.

 * @summary Update a container
 */
export const containerUpdate = (
  endpointId: number,
  id: string,
  containerUpdateBody: ContainerUpdateBody,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ContainerUpdate200>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/${id}/update`,
    containerUpdateBody,
    options
  );

export const getContainerUpdateMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerUpdate>>,
    TError,
    { endpointId: number; id: string; data: ContainerUpdateBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerUpdate>>,
  TError,
  { endpointId: number; id: string; data: ContainerUpdateBody },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerUpdate>>,
    { endpointId: number; id: string; data: ContainerUpdateBody }
  > = (props) => {
    const { endpointId, id, data } = props ?? {};

    return containerUpdate(endpointId, id, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerUpdate>>
>;
export type ContainerUpdateMutationBody = ContainerUpdateBody;
export type ContainerUpdateMutationError = AxiosError<ErrorResponse>;

export const useContainerUpdate = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerUpdate>>,
    TError,
    { endpointId: number; id: string; data: ContainerUpdateBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Rename a container
 */
export const containerRename = (
  endpointId: number,
  id: string,
  params: ContainerRenameParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/${id}/rename`,
    undefined,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getContainerRenameMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerRename>>,
    TError,
    { endpointId: number; id: string; params: ContainerRenameParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerRename>>,
  TError,
  { endpointId: number; id: string; params: ContainerRenameParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerRename>>,
    { endpointId: number; id: string; params: ContainerRenameParams }
  > = (props) => {
    const { endpointId, id, params } = props ?? {};

    return containerRename(endpointId, id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerRenameMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerRename>>
>;

export type ContainerRenameMutationError = AxiosError<ErrorResponse>;

export const useContainerRename = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerRename>>,
    TError,
    { endpointId: number; id: string; params: ContainerRenameParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerRenameMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Use the freezer cgroup to suspend all processes in a container.

Traditionally, when suspending a process the `SIGSTOP` signal is used,
which is observable by the process being suspended. With the freezer
cgroup the process is unaware, and unable to capture, that it is being
suspended, and subsequently resumed.

 * @summary Pause a container
 */
export const containerPause = (
  endpointId: number,
  id: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/${id}/pause`,
    undefined,
    options
  );

export const getContainerPauseMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerPause>>,
    TError,
    { endpointId: number; id: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerPause>>,
  TError,
  { endpointId: number; id: string },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerPause>>,
    { endpointId: number; id: string }
  > = (props) => {
    const { endpointId, id } = props ?? {};

    return containerPause(endpointId, id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerPauseMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerPause>>
>;

export type ContainerPauseMutationError = AxiosError<ErrorResponse>;

export const useContainerPause = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerPause>>,
    TError,
    { endpointId: number; id: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerPauseMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Resume a container which has been paused.
 * @summary Unpause a container
 */
export const containerUnpause = (
  endpointId: number,
  id: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/${id}/unpause`,
    undefined,
    options
  );

export const getContainerUnpauseMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerUnpause>>,
    TError,
    { endpointId: number; id: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerUnpause>>,
  TError,
  { endpointId: number; id: string },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerUnpause>>,
    { endpointId: number; id: string }
  > = (props) => {
    const { endpointId, id } = props ?? {};

    return containerUnpause(endpointId, id, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerUnpauseMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerUnpause>>
>;

export type ContainerUnpauseMutationError = AxiosError<ErrorResponse>;

export const useContainerUnpause = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerUnpause>>,
    TError,
    { endpointId: number; id: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerUnpauseMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Attach to a container to read its output or send it input. You can attach
to the same container multiple times and you can reattach to containers
that have been detached.

Either the `stream` or `logs` parameter must be `true` for this endpoint
to do anything.

See the [documentation for the `docker attach` command](/engine/reference/commandline/attach/)
for more details.

### Hijacking

This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`,
and `stderr` on the same socket.

This is the response from the daemon for an attach request:

```
HTTP/1.1 200 OK
Content-Type: application/vnd.docker.raw-stream

[STREAM]
```

After the headers and two new lines, the TCP connection can now be used
for raw, bidirectional communication between the client and server.

To hint potential proxies about connection hijacking, the Docker client
can also optionally send connection upgrade headers.

For example, the client sends this request to upgrade the connection:

```
POST /containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1
Upgrade: tcp
Connection: Upgrade
```

The Docker daemon will respond with a `101 UPGRADED` response, and will
similarly follow with the raw stream:

```
HTTP/1.1 101 UPGRADED
Content-Type: application/vnd.docker.raw-stream
Connection: Upgrade
Upgrade: tcp

[STREAM]
```

### Stream format

When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate),
the stream over the hijacked connected is multiplexed to separate out
`stdout` and `stderr`. The stream consists of a series of frames, each
containing a header and a payload.

The header contains the information which the stream writes (`stdout` or
`stderr`). It also contains the size of the associated frame encoded in
the last four bytes (`uint32`).

It is encoded on the first eight bytes like this:

```go
header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
```

`STREAM_TYPE` can be:

- 0: `stdin` (is written on `stdout`)
- 1: `stdout`
- 2: `stderr`

`SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size
encoded as big endian.

Following the header is the payload, which is the specified number of
bytes of `STREAM_TYPE`.

The simplest way to implement this protocol is the following:

1. Read 8 bytes.
2. Choose `stdout` or `stderr` depending on the first byte.
3. Extract the frame size from the last four bytes.
4. Read the extracted size and output it on the correct output.
5. Goto 1.

### Stream format when using a TTY

When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate),
the stream is not multiplexed. The data exchanged over the hijacked
connection is simply the raw data from the process PTY and client's
`stdin`.

 * @summary Attach to a container
 */
export const containerAttach = (
  endpointId: number,
  id: string,
  params?: ContainerAttachParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/${id}/attach`,
    undefined,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getContainerAttachMutationOptions = <
  TError = AxiosError<void | ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerAttach>>,
    TError,
    { endpointId: number; id: string; params?: ContainerAttachParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerAttach>>,
  TError,
  { endpointId: number; id: string; params?: ContainerAttachParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerAttach>>,
    { endpointId: number; id: string; params?: ContainerAttachParams }
  > = (props) => {
    const { endpointId, id, params } = props ?? {};

    return containerAttach(endpointId, id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerAttachMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerAttach>>
>;

export type ContainerAttachMutationError = AxiosError<void | ErrorResponse>;

export const useContainerAttach = <
  TError = AxiosError<void | ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerAttach>>,
    TError,
    { endpointId: number; id: string; params?: ContainerAttachParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerAttachMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Attach to a container via a websocket
 */
export const containerAttachWebsocket = (
  endpointId: number,
  id: string,
  params?: ContainerAttachWebsocketParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> =>
  axios.get(`/endpoints/${endpointId}/docker/containers/${id}/attach/ws`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getContainerAttachWebsocketQueryKey = (
  endpointId: number,
  id: string,
  params?: ContainerAttachWebsocketParams
) =>
  [
    `/endpoints/${endpointId}/docker/containers/${id}/attach/ws`,
    ...(params ? [params] : []),
  ] as const;

export const getContainerAttachWebsocketQueryOptions = <
  TData = Awaited<ReturnType<typeof containerAttachWebsocket>>,
  TError = AxiosError<void | ErrorResponse>
>(
  endpointId: number,
  id: string,
  params?: ContainerAttachWebsocketParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerAttachWebsocket>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof containerAttachWebsocket>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getContainerAttachWebsocketQueryKey(endpointId, id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof containerAttachWebsocket>>
  > = ({ signal }) =>
    containerAttachWebsocket(endpointId, id, params, {
      signal,
      ...axiosOptions,
    });

  return { queryKey, queryFn, enabled: !!(endpointId && id), ...queryOptions };
};

export type ContainerAttachWebsocketQueryResult = NonNullable<
  Awaited<ReturnType<typeof containerAttachWebsocket>>
>;
export type ContainerAttachWebsocketQueryError =
  AxiosError<void | ErrorResponse>;

export const useContainerAttachWebsocket = <
  TData = Awaited<ReturnType<typeof containerAttachWebsocket>>,
  TError = AxiosError<void | ErrorResponse>
>(
  endpointId: number,
  id: string,
  params?: ContainerAttachWebsocketParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerAttachWebsocket>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContainerAttachWebsocketQueryOptions(
    endpointId,
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Block until a container stops, then returns the exit code.
 * @summary Wait for a container
 */
export const containerWait = (
  endpointId: number,
  id: string,
  params?: ContainerWaitParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ContainerWaitResponse>> =>
  axios.post(
    `/endpoints/${endpointId}/docker/containers/${id}/wait`,
    undefined,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getContainerWaitMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerWait>>,
    TError,
    { endpointId: number; id: string; params?: ContainerWaitParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerWait>>,
  TError,
  { endpointId: number; id: string; params?: ContainerWaitParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerWait>>,
    { endpointId: number; id: string; params?: ContainerWaitParams }
  > = (props) => {
    const { endpointId, id, params } = props ?? {};

    return containerWait(endpointId, id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerWaitMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerWait>>
>;

export type ContainerWaitMutationError = AxiosError<ErrorResponse>;

export const useContainerWait = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerWait>>,
    TError,
    { endpointId: number; id: string; params?: ContainerWaitParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerWaitMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Remove a container
 */
export const containerDelete = (
  endpointId: number,
  id: string,
  params?: ContainerDeleteParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.delete(`/endpoints/${endpointId}/docker/containers/${id}`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getContainerDeleteMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerDelete>>,
    TError,
    { endpointId: number; id: string; params?: ContainerDeleteParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerDelete>>,
  TError,
  { endpointId: number; id: string; params?: ContainerDeleteParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerDelete>>,
    { endpointId: number; id: string; params?: ContainerDeleteParams }
  > = (props) => {
    const { endpointId, id, params } = props ?? {};

    return containerDelete(endpointId, id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerDelete>>
>;

export type ContainerDeleteMutationError = AxiosError<ErrorResponse>;

export const useContainerDelete = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerDelete>>,
    TError,
    { endpointId: number; id: string; params?: ContainerDeleteParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerDeleteMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * A response header `X-Docker-Container-Path-Stat` is returned, containing
a base64 - encoded JSON object with some filesystem header information
about the path.

 * @summary Get information about files in a container
 */
export const containerArchiveInfo = (
  endpointId: number,
  id: string,
  params: ContainerArchiveInfoParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.head(`/endpoints/${endpointId}/docker/containers/${id}/archive`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getContainerArchiveInfoMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerArchiveInfo>>,
    TError,
    { endpointId: number; id: string; params: ContainerArchiveInfoParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerArchiveInfo>>,
  TError,
  { endpointId: number; id: string; params: ContainerArchiveInfoParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerArchiveInfo>>,
    { endpointId: number; id: string; params: ContainerArchiveInfoParams }
  > = (props) => {
    const { endpointId, id, params } = props ?? {};

    return containerArchiveInfo(endpointId, id, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerArchiveInfoMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerArchiveInfo>>
>;

export type ContainerArchiveInfoMutationError = AxiosError<ErrorResponse>;

export const useContainerArchiveInfo = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerArchiveInfo>>,
    TError,
    { endpointId: number; id: string; params: ContainerArchiveInfoParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerArchiveInfoMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get a tar archive of a resource in the filesystem of container id.
 * @summary Get an archive of a filesystem resource in a container
 */
export const containerArchive = (
  endpointId: number,
  id: string,
  params: ContainerArchiveParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.get(`/endpoints/${endpointId}/docker/containers/${id}/archive`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getContainerArchiveQueryKey = (
  endpointId: number,
  id: string,
  params: ContainerArchiveParams
) =>
  [
    `/endpoints/${endpointId}/docker/containers/${id}/archive`,
    ...(params ? [params] : []),
  ] as const;

export const getContainerArchiveQueryOptions = <
  TData = Awaited<ReturnType<typeof containerArchive>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  params: ContainerArchiveParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerArchive>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<
  Awaited<ReturnType<typeof containerArchive>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getContainerArchiveQueryKey(endpointId, id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof containerArchive>>
  > = ({ signal }) =>
    containerArchive(endpointId, id, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!(endpointId && id), ...queryOptions };
};

export type ContainerArchiveQueryResult = NonNullable<
  Awaited<ReturnType<typeof containerArchive>>
>;
export type ContainerArchiveQueryError = AxiosError<ErrorResponse>;

export const useContainerArchive = <
  TData = Awaited<ReturnType<typeof containerArchive>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  id: string,
  params: ContainerArchiveParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof containerArchive>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContainerArchiveQueryOptions(
    endpointId,
    id,
    params,
    options
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Upload a tar archive to be extracted to a path in the filesystem of container id.
`path` parameter is asserted to be a directory. If it exists as a file, 400 error
will be returned with message "not a directory".

 * @summary Extract an archive of files or folders to a directory in a container
 */
export const putContainerArchive = (
  endpointId: number,
  id: string,
  putContainerArchiveBody: Blob,
  params: PutContainerArchiveParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.put(
    `/endpoints/${endpointId}/docker/containers/${id}/archive`,
    putContainerArchiveBody,
    {
      ...options,
      params: { ...params, ...options?.params },
    }
  );

export const getPutContainerArchiveMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putContainerArchive>>,
    TError,
    {
      endpointId: number;
      id: string;
      data: Blob;
      params: PutContainerArchiveParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putContainerArchive>>,
  TError,
  {
    endpointId: number;
    id: string;
    data: Blob;
    params: PutContainerArchiveParams;
  },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putContainerArchive>>,
    {
      endpointId: number;
      id: string;
      data: Blob;
      params: PutContainerArchiveParams;
    }
  > = (props) => {
    const { endpointId, id, data, params } = props ?? {};

    return putContainerArchive(endpointId, id, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutContainerArchiveMutationResult = NonNullable<
  Awaited<ReturnType<typeof putContainerArchive>>
>;
export type PutContainerArchiveMutationBody = Blob;
export type PutContainerArchiveMutationError = AxiosError<ErrorResponse>;

export const usePutContainerArchive = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putContainerArchive>>,
    TError,
    {
      endpointId: number;
      id: string;
      data: Blob;
      params: PutContainerArchiveParams;
    },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getPutContainerArchiveMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Delete stopped containers
 */
export const containerPrune = (
  endpointId: number,
  params?: ContainerPruneParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ContainerPrune200>> =>
  axios.post(`/endpoints/${endpointId}/docker/containers/prune`, undefined, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getContainerPruneMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerPrune>>,
    TError,
    { endpointId: number; params?: ContainerPruneParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof containerPrune>>,
  TError,
  { endpointId: number; params?: ContainerPruneParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof containerPrune>>,
    { endpointId: number; params?: ContainerPruneParams }
  > = (props) => {
    const { endpointId, params } = props ?? {};

    return containerPrune(endpointId, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContainerPruneMutationResult = NonNullable<
  Awaited<ReturnType<typeof containerPrune>>
>;

export type ContainerPruneMutationError = AxiosError<ErrorResponse>;

export const useContainerPrune = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof containerPrune>>,
    TError,
    { endpointId: number; params?: ContainerPruneParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getContainerPruneMutationOptions(options);

  return useMutation(mutationOptions);
};
