/**
 * Generated by orval v6.15.0 üç∫
 * Do not edit manually.
 * Docker Engine API
 * The Engine API is an HTTP API served by Docker Engine. It is the API the
Docker client uses to communicate with the Engine, so everything the Docker
client can do can be done with the API.

Most of the client's commands map directly to API endpoints (e.g. `docker ps`
is `GET /containers/json`). The notable exception is running containers,
which consists of several API calls.

# Errors

The API uses standard HTTP status codes to indicate the success or failure
of the API call. The body of the response will be JSON in the following
format:

```
{
  "message": "page not found"
}
```

# Versioning

The API is usually changed in each release, so API calls are versioned to
ensure that clients don't break. To lock to a specific version of the API,
you prefix the URL with its version, for example, call `/v1.30/info` to use
the v1.30 version of the `/info` endpoint. If the API version specified in
the URL is not supported by the daemon, a HTTP `400 Bad Request` error message
is returned.

If you omit the version-prefix, the current version of the API (v1.41) is used.
For example, calling `/info` is the same as calling `/v1.41/info`. Using the
API without a version-prefix is deprecated and will be removed in a future release.

Engine releases in the near future should support this version of the API,
so your client will continue to work even if it is talking to a newer Engine.

The API uses an open schema model, which means server may add extra properties
to responses. Likewise, the server will ignore any extra query parameters and
request body properties. When you write clients, you need to ignore additional
properties in responses to ensure they do not break when talking to newer
daemons.


# Authentication

Authentication for registries is handled client side. The client has to send
authentication details to various endpoints that need to communicate with
registries, such as `POST /images/(name)/push`. These are sent as
`X-Registry-Auth` header as a [base64url encoded](https://tools.ietf.org/html/rfc4648#section-5)
(JSON) string with the following structure:

```
{
  "username": "string",
  "password": "string",
  "email": "string",
  "serveraddress": "string"
}
```

The `serveraddress` is a domain/IP without a protocol. Throughout this
structure, double quotes are required.

If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth),
you can just pass this instead of credentials:

```
{
  "identitytoken": "9cbaf023786cd7..."
}
```

 * OpenAPI spec version: 1.41
 */
import axios from 'axios';
import type { AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { useQuery, useMutation } from 'react-query';
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from 'react-query';

import type {
  ImageSummary,
  ErrorResponse,
  ImageListParams,
  ImageBuildParams,
  BuildPrune200,
  BuildPruneParams,
  ImageCreateParams,
  ImageInspect,
  ImageHistory200Item,
  ImagePushParams,
  ImageTagParams,
  ImageDeleteResponseItem,
  ImageDeleteParams,
  ImageSearch200Item,
  ImageSearchParams,
  ImagePrune200,
  ImagePruneParams,
  IdResponse,
  ContainerConfig,
  ImageCommitParams,
  ImageGetAllParams,
  ImageLoadParams,
} from '../dockerEngineAPI.schemas';

/**
 * Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
 * @summary List Images
 */
export const imageList = (
  endpointId: number,
  params?: ImageListParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ImageSummary[]>> =>
  axios.get(`/endpoints/${endpointId}/docker/images/json`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getImageListQueryKey = (
  endpointId: number,
  params?: ImageListParams
) =>
  [
    `/endpoints/${endpointId}/docker/images/json`,
    ...(params ? [params] : []),
  ] as const;

export const getImageListQueryOptions = <
  TData = Awaited<ReturnType<typeof imageList>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  params?: ImageListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof imageList>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getImageListQueryKey(endpointId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof imageList>>> = ({
    signal,
  }) => imageList(endpointId, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!endpointId, ...queryOptions };
};

export type ImageListQueryResult = NonNullable<
  Awaited<ReturnType<typeof imageList>>
>;
export type ImageListQueryError = AxiosError<ErrorResponse>;

export const useImageList = <
  TData = Awaited<ReturnType<typeof imageList>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  params?: ImageListParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageList>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getImageListQueryOptions(endpointId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Build an image from a tar archive with a `Dockerfile` in it.

The `Dockerfile` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the `dockerfile` parameter. [See the `Dockerfile` reference for more information](/engine/reference/builder/).

The Docker daemon performs a preliminary validation of the `Dockerfile` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.

The build is canceled if the client drops the connection by quitting or being killed.

 * @summary Build an image
 */
export const imageBuild = (
  endpointId: number,
  imageBuildBody: Blob,
  params?: ImageBuildParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/endpoints/${endpointId}/docker/build`, imageBuildBody, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getImageBuildMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageBuild>>,
    TError,
    { endpointId: number; data: Blob; params?: ImageBuildParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof imageBuild>>,
  TError,
  { endpointId: number; data: Blob; params?: ImageBuildParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof imageBuild>>,
    { endpointId: number; data: Blob; params?: ImageBuildParams }
  > = (props) => {
    const { endpointId, data, params } = props ?? {};

    return imageBuild(endpointId, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImageBuildMutationResult = NonNullable<
  Awaited<ReturnType<typeof imageBuild>>
>;
export type ImageBuildMutationBody = Blob;
export type ImageBuildMutationError = AxiosError<ErrorResponse>;

export const useImageBuild = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageBuild>>,
    TError,
    { endpointId: number; data: Blob; params?: ImageBuildParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getImageBuildMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Delete builder cache
 */
export const buildPrune = (
  endpointId: number,
  params?: BuildPruneParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<BuildPrune200>> =>
  axios.post(`/endpoints/${endpointId}/docker/build/prune`, undefined, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getBuildPruneMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof buildPrune>>,
    TError,
    { endpointId: number; params?: BuildPruneParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof buildPrune>>,
  TError,
  { endpointId: number; params?: BuildPruneParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof buildPrune>>,
    { endpointId: number; params?: BuildPruneParams }
  > = (props) => {
    const { endpointId, params } = props ?? {};

    return buildPrune(endpointId, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type BuildPruneMutationResult = NonNullable<
  Awaited<ReturnType<typeof buildPrune>>
>;

export type BuildPruneMutationError = AxiosError<ErrorResponse>;

export const useBuildPrune = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof buildPrune>>,
    TError,
    { endpointId: number; params?: BuildPruneParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getBuildPruneMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Create an image by either pulling it from a registry or importing it.
 * @summary Create an image
 */
export const imageCreate = (
  endpointId: number,
  imageCreateBody: string,
  params?: ImageCreateParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/endpoints/${endpointId}/docker/images/create`, imageCreateBody, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getImageCreateMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageCreate>>,
    TError,
    { endpointId: number; data: string; params?: ImageCreateParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof imageCreate>>,
  TError,
  { endpointId: number; data: string; params?: ImageCreateParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof imageCreate>>,
    { endpointId: number; data: string; params?: ImageCreateParams }
  > = (props) => {
    const { endpointId, data, params } = props ?? {};

    return imageCreate(endpointId, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImageCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof imageCreate>>
>;
export type ImageCreateMutationBody = string;
export type ImageCreateMutationError = AxiosError<ErrorResponse>;

export const useImageCreate = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageCreate>>,
    TError,
    { endpointId: number; data: string; params?: ImageCreateParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getImageCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Return low-level information about an image.
 * @summary Inspect an image
 */
export const imageInspect = (
  endpointId: number,
  name: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ImageInspect>> =>
  axios.get(`/endpoints/${endpointId}/docker/images/${name}/json`, options);

export const getImageInspectQueryKey = (endpointId: number, name: string) =>
  [`/endpoints/${endpointId}/docker/images/${name}/json`] as const;

export const getImageInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof imageInspect>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof imageInspect>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getImageInspectQueryKey(endpointId, name);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof imageInspect>>> = ({
    signal,
  }) => imageInspect(endpointId, name, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!(endpointId && name),
    ...queryOptions,
  };
};

export type ImageInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof imageInspect>>
>;
export type ImageInspectQueryError = AxiosError<ErrorResponse>;

export const useImageInspect = <
  TData = Awaited<ReturnType<typeof imageInspect>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageInspect>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getImageInspectQueryOptions(endpointId, name, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Return parent layers of an image.
 * @summary Get the history of an image
 */
export const imageHistory = (
  endpointId: number,
  name: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ImageHistory200Item[]>> =>
  axios.get(`/endpoints/${endpointId}/docker/images/${name}/history`, options);

export const getImageHistoryQueryKey = (endpointId: number, name: string) =>
  [`/endpoints/${endpointId}/docker/images/${name}/history`] as const;

export const getImageHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof imageHistory>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageHistory>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof imageHistory>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getImageHistoryQueryKey(endpointId, name);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof imageHistory>>> = ({
    signal,
  }) => imageHistory(endpointId, name, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!(endpointId && name),
    ...queryOptions,
  };
};

export type ImageHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof imageHistory>>
>;
export type ImageHistoryQueryError = AxiosError<ErrorResponse>;

export const useImageHistory = <
  TData = Awaited<ReturnType<typeof imageHistory>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageHistory>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getImageHistoryQueryOptions(endpointId, name, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Push an image to a registry.

If you wish to push an image on to a private registry, that image must
already have a tag which references the registry. For example,
`registry.example.com/myimage:latest`.

The push is cancelled if the HTTP connection is closed.

 * @summary Push an image
 */
export const imagePush = (
  endpointId: number,
  name: string,
  params?: ImagePushParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/endpoints/${endpointId}/docker/images/${name}/push`, undefined, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getImagePushMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imagePush>>,
    TError,
    { endpointId: number; name: string; params?: ImagePushParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof imagePush>>,
  TError,
  { endpointId: number; name: string; params?: ImagePushParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof imagePush>>,
    { endpointId: number; name: string; params?: ImagePushParams }
  > = (props) => {
    const { endpointId, name, params } = props ?? {};

    return imagePush(endpointId, name, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImagePushMutationResult = NonNullable<
  Awaited<ReturnType<typeof imagePush>>
>;

export type ImagePushMutationError = AxiosError<ErrorResponse>;

export const useImagePush = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imagePush>>,
    TError,
    { endpointId: number; name: string; params?: ImagePushParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getImagePushMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Tag an image so that it becomes part of a repository.
 * @summary Tag an image
 */
export const imageTag = (
  endpointId: number,
  name: string,
  params?: ImageTagParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/endpoints/${endpointId}/docker/images/${name}/tag`, undefined, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getImageTagMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageTag>>,
    TError,
    { endpointId: number; name: string; params?: ImageTagParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof imageTag>>,
  TError,
  { endpointId: number; name: string; params?: ImageTagParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof imageTag>>,
    { endpointId: number; name: string; params?: ImageTagParams }
  > = (props) => {
    const { endpointId, name, params } = props ?? {};

    return imageTag(endpointId, name, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImageTagMutationResult = NonNullable<
  Awaited<ReturnType<typeof imageTag>>
>;

export type ImageTagMutationError = AxiosError<ErrorResponse>;

export const useImageTag = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageTag>>,
    TError,
    { endpointId: number; name: string; params?: ImageTagParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getImageTagMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Remove an image, along with any untagged parent images that were
referenced by that image.

Images can't be removed if they have descendant images, are being
used by a running container or are being used by a build.

 * @summary Remove an image
 */
export const imageDelete = (
  endpointId: number,
  name: string,
  params?: ImageDeleteParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ImageDeleteResponseItem[]>> =>
  axios.delete(`/endpoints/${endpointId}/docker/images/${name}`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getImageDeleteMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageDelete>>,
    TError,
    { endpointId: number; name: string; params?: ImageDeleteParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof imageDelete>>,
  TError,
  { endpointId: number; name: string; params?: ImageDeleteParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof imageDelete>>,
    { endpointId: number; name: string; params?: ImageDeleteParams }
  > = (props) => {
    const { endpointId, name, params } = props ?? {};

    return imageDelete(endpointId, name, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImageDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof imageDelete>>
>;

export type ImageDeleteMutationError = AxiosError<ErrorResponse>;

export const useImageDelete = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageDelete>>,
    TError,
    { endpointId: number; name: string; params?: ImageDeleteParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getImageDeleteMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Search for an image on Docker Hub.
 * @summary Search images
 */
export const imageSearch = (
  endpointId: number,
  params: ImageSearchParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ImageSearch200Item[]>> =>
  axios.get(`/endpoints/${endpointId}/docker/images/search`, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getImageSearchQueryKey = (
  endpointId: number,
  params: ImageSearchParams
) =>
  [
    `/endpoints/${endpointId}/docker/images/search`,
    ...(params ? [params] : []),
  ] as const;

export const getImageSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof imageSearch>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  params: ImageSearchParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageSearch>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof imageSearch>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getImageSearchQueryKey(endpointId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof imageSearch>>> = ({
    signal,
  }) => imageSearch(endpointId, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!endpointId, ...queryOptions };
};

export type ImageSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof imageSearch>>
>;
export type ImageSearchQueryError = AxiosError<ErrorResponse>;

export const useImageSearch = <
  TData = Awaited<ReturnType<typeof imageSearch>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  params: ImageSearchParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageSearch>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getImageSearchQueryOptions(endpointId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Delete unused images
 */
export const imagePrune = (
  endpointId: number,
  params?: ImagePruneParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ImagePrune200>> =>
  axios.post(`/endpoints/${endpointId}/docker/images/prune`, undefined, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getImagePruneMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imagePrune>>,
    TError,
    { endpointId: number; params?: ImagePruneParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof imagePrune>>,
  TError,
  { endpointId: number; params?: ImagePruneParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof imagePrune>>,
    { endpointId: number; params?: ImagePruneParams }
  > = (props) => {
    const { endpointId, params } = props ?? {};

    return imagePrune(endpointId, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImagePruneMutationResult = NonNullable<
  Awaited<ReturnType<typeof imagePrune>>
>;

export type ImagePruneMutationError = AxiosError<ErrorResponse>;

export const useImagePrune = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imagePrune>>,
    TError,
    { endpointId: number; params?: ImagePruneParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getImagePruneMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Create a new image from a container
 */
export const imageCommit = (
  endpointId: number,
  containerConfig: ContainerConfig,
  params?: ImageCommitParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<IdResponse>> =>
  axios.post(`/endpoints/${endpointId}/docker/commit`, containerConfig, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getImageCommitMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageCommit>>,
    TError,
    { endpointId: number; data: ContainerConfig; params?: ImageCommitParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof imageCommit>>,
  TError,
  { endpointId: number; data: ContainerConfig; params?: ImageCommitParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof imageCommit>>,
    { endpointId: number; data: ContainerConfig; params?: ImageCommitParams }
  > = (props) => {
    const { endpointId, data, params } = props ?? {};

    return imageCommit(endpointId, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImageCommitMutationResult = NonNullable<
  Awaited<ReturnType<typeof imageCommit>>
>;
export type ImageCommitMutationBody = ContainerConfig;
export type ImageCommitMutationError = AxiosError<ErrorResponse>;

export const useImageCommit = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageCommit>>,
    TError,
    { endpointId: number; data: ContainerConfig; params?: ImageCommitParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getImageCommitMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Get a tarball containing all images and metadata for a repository.

If `name` is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name` is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the `repositories` file in the tarball, as there were no image names referenced.

### Image tarball format

An image tarball contains one directory per image layer (named using its long ID), each containing these files:

- `VERSION`: currently `1.0` - the file format version
- `json`: detailed layer information, similar to `docker inspect layer_id`
- `layer.tar`: A tarfile containing the filesystem changes in this layer

The `layer.tar` file contains `aufs` style `.wh..wh.aufs` files and directories for storing attribute changes and deletions.

If the tarball defines a repository, the tarball should also include a `repositories` file at the root that contains a list of repository and tag names mapped to layer IDs.

```json
{
  "hello-world": {
    "latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"
  }
}
```

 * @summary Export an image
 */
export const imageGet = (
  endpointId: number,
  name: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Blob>> =>
  axios.get(`/endpoints/${endpointId}/docker/images/${name}/get`, {
    responseType: 'blob',
    ...options,
  });

export const getImageGetQueryKey = (endpointId: number, name: string) =>
  [`/endpoints/${endpointId}/docker/images/${name}/get`] as const;

export const getImageGetQueryOptions = <
  TData = Awaited<ReturnType<typeof imageGet>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageGet>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof imageGet>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getImageGetQueryKey(endpointId, name);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof imageGet>>> = ({
    signal,
  }) => imageGet(endpointId, name, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!(endpointId && name),
    ...queryOptions,
  };
};

export type ImageGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof imageGet>>
>;
export type ImageGetQueryError = AxiosError<ErrorResponse>;

export const useImageGet = <
  TData = Awaited<ReturnType<typeof imageGet>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageGet>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getImageGetQueryOptions(endpointId, name, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Get a tarball containing all images and metadata for several image
repositories.

For each value of the `names` parameter: if it is a specific name and
tag (e.g. `ubuntu:latest`), then only that image (and its parents) are
returned; if it is an image ID, similarly only that image (and its parents)
are returned and there would be no names referenced in the 'repositories'
file for this image ID.

For details on the format, see the [export image endpoint](#operation/ImageGet).

 * @summary Export several images
 */
export const imageGetAll = (
  endpointId: number,
  params?: ImageGetAllParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Blob>> =>
  axios.get(`/endpoints/${endpointId}/docker/images/get`, {
    responseType: 'blob',
    ...options,
    params: { ...params, ...options?.params },
  });

export const getImageGetAllQueryKey = (
  endpointId: number,
  params?: ImageGetAllParams
) =>
  [
    `/endpoints/${endpointId}/docker/images/get`,
    ...(params ? [params] : []),
  ] as const;

export const getImageGetAllQueryOptions = <
  TData = Awaited<ReturnType<typeof imageGetAll>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  params?: ImageGetAllParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageGetAll>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryOptions<Awaited<ReturnType<typeof imageGetAll>>, TError, TData> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getImageGetAllQueryKey(endpointId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof imageGetAll>>> = ({
    signal,
  }) => imageGetAll(endpointId, params, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!endpointId, ...queryOptions };
};

export type ImageGetAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof imageGetAll>>
>;
export type ImageGetAllQueryError = AxiosError<ErrorResponse>;

export const useImageGetAll = <
  TData = Awaited<ReturnType<typeof imageGetAll>>,
  TError = AxiosError<ErrorResponse>
>(
  endpointId: number,
  params?: ImageGetAllParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof imageGetAll>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getImageGetAllQueryOptions(endpointId, params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Load a set of images and tags into a repository.

For details on the format, see the [export image endpoint](#operation/ImageGet).

 * @summary Import images
 */
export const imageLoad = (
  endpointId: number,
  imageLoadBody: Blob,
  params?: ImageLoadParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> =>
  axios.post(`/endpoints/${endpointId}/docker/images/load`, imageLoadBody, {
    ...options,
    params: { ...params, ...options?.params },
  });

export const getImageLoadMutationOptions = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageLoad>>,
    TError,
    { endpointId: number; data: Blob; params?: ImageLoadParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof imageLoad>>,
  TError,
  { endpointId: number; data: Blob; params?: ImageLoadParams },
  TContext
> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof imageLoad>>,
    { endpointId: number; data: Blob; params?: ImageLoadParams }
  > = (props) => {
    const { endpointId, data, params } = props ?? {};

    return imageLoad(endpointId, data, params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ImageLoadMutationResult = NonNullable<
  Awaited<ReturnType<typeof imageLoad>>
>;
export type ImageLoadMutationBody = Blob;
export type ImageLoadMutationError = AxiosError<ErrorResponse>;

export const useImageLoad = <
  TError = AxiosError<ErrorResponse>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof imageLoad>>,
    TError,
    { endpointId: number; data: Blob; params?: ImageLoadParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getImageLoadMutationOptions(options);

  return useMutation(mutationOptions);
};
